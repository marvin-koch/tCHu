Index: src/ch/epfl/tchu/gui/ServerMain.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ch.epfl.tchu.gui;\r\n\r\nimport ch.epfl.tchu.SortedBag;\r\nimport ch.epfl.tchu.game.*;\r\nimport ch.epfl.tchu.net.RemotePlayerProxy;\r\nimport javafx.application.Application;\r\nimport javafx.beans.binding.Bindings;\r\nimport javafx.beans.property.*;\r\nimport javafx.event.Event;\r\nimport javafx.geometry.HPos;\r\nimport javafx.geometry.Pos;\r\nimport javafx.scene.Scene;\r\nimport javafx.scene.control.Button;\r\nimport javafx.scene.control.Label;\r\nimport javafx.scene.control.TextField;\r\nimport javafx.scene.layout.GridPane;\r\nimport javafx.stage.Stage;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.PrintWriter;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\nimport java.util.*;\r\n\r\n/**\r\n * La classe ServerMain contient le programme principal du serveur tCHu.\r\n * @author Shangeeth Poobalasingam (329307)\r\n * @author Marvin Koch (324448)\r\n */\r\npublic final class ServerMain extends Application {\r\n    public static Boolean is3Player = true;\r\n    /**\r\n     * Méthode main qui appelle launch\r\n     * @param args arguments\r\n     */\r\n    public static void main(String[] args){\r\n        launch(args);\r\n    }\r\n    /**\r\n     * The main entry point for all JavaFX applications.\r\n     * The start method is called after the init method has returned,\r\n     * and after the system is ready for the application to begin running.\r\n     *\r\n     * <p>\r\n     * NOTE: This method is called on the JavaFX Application Thread.\r\n     * </p>\r\n     *\r\n     *\r\n     *\r\n     * La méthode start du serveur ignore son argument primaryStage et se charge de démarrer le serveur en:\r\n     * - analysant les arguments passés au programme afin de déterminer les noms des deux joueurs,\r\n     * - attendant une connexion de la part du client sur le port 5108,\r\n     * - créant les deux joueurs, le premier étant un joueur graphique, le second un mandataire du joueur distant qui se trouve sur le client,\r\n     * - démarrant le fil d'exécution gérant la partie, qui ne fait rien d'autre qu'exécuter la méthode play de Game.\r\n     *\r\n     * @param primaryStage the primary stage for this application, onto which\r\n     *                     the application scene can be set.\r\n     *                     Applications may create other stages, if needed, but they will not be\r\n     *                     primary stages.\r\n     * @throws Exception if something goes wrong\r\n     */\r\n    @Override\r\n    public void start(Stage primaryStage) throws IOException {\r\n        ServerSocket serverSocket = new ServerSocket(5108);\r\n        Socket socket = serverSocket.accept();\r\n        Socket socket2 = serverSocket.accept();\r\n\r\n        /*\r\n        StringProperty text1Property = new SimpleStringProperty();\r\n        StringProperty text2Property = new SimpleStringProperty();\r\n\r\n        Stage menu = new Stage();\r\n        menu.setTitle(\"Bienvenue dans tCHu!\");\r\n        menu.setOnCloseRequest(Event::consume);\r\n\r\n        TextField player1Text = new TextField();\r\n        TextField player2Text = new TextField();\r\n        Bindings.bindBidirectional(player1Text.textProperty(), text1Property);\r\n        Bindings.bindBidirectional(player2Text.textProperty(), text2Property);\r\n\r\n        GridPane pane = new GridPane();\r\n        pane.setAlignment(Pos.CENTER);\r\n        pane.setHgap(5.5);\r\n        pane.setVgap(5.5);\r\n        pane.add(new Label(\"Joueur 1:\"), 0, 0);\r\n        pane.add(player1Text, 1, 0);\r\n        pane.add(new Label(\"Joueur 2:\"), 0, 1);\r\n        pane.add(player2Text, 1, 1);\r\n        Button playButton = new Button(\"Play\");\r\n        pane.add(playButton, 1, 3);\r\n        GridPane.setHalignment(playButton, HPos.RIGHT);\r\n\r\n        Scene scene = new Scene(pane );\r\n        menu.setScene(scene);\r\n        menu.show();\r\n\r\n         */\r\n        Button playButton = new Button(\"Jouer\");\r\n        GameMenu.createMenuStage(\"Joueur 1\", \"Joueur 2\", playButton);\r\n\r\n        playButton.setOnAction(e -> {\r\n            playButton.disableProperty().set(true);\r\n            Thread thread = new Thread(() ->{\r\n                String player1Name = GameMenu.getText1() == null ? \"Ada\" : GameMenu.getText1();\r\n                String player2Name = GameMenu.getText2() == null ? \"Charles\" : GameMenu.getText2();\r\n\r\n                Map<PlayerId,String> playerNames = new EnumMap<>(PlayerId.class);\r\n                Map<PlayerId,Player> playerIdPlayerMap = new EnumMap<>(PlayerId.class);\r\n\r\n                playerNames.put(PlayerId.PLAYER_1,player1Name);\r\n                playerNames.put(PlayerId.PLAYER_2, player2Name);\r\n                playerIdPlayerMap.put(PlayerId.PLAYER_1,new GraphicalPlayerAdapter());\r\n                playerIdPlayerMap.put(PlayerId.PLAYER_2,new RemotePlayerProxy(socket));\r\n                Game.play(playerIdPlayerMap, playerNames, SortedBag.of(ChMap.tickets()), new Random());\r\n                //menu.hide();\r\n            });\r\n            thread.start();\r\n            //((Node)(e.getSource())).getScene().getWindow().hide();\r\n        });\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ch/epfl/tchu/gui/ServerMain.java b/src/ch/epfl/tchu/gui/ServerMain.java
--- a/src/ch/epfl/tchu/gui/ServerMain.java	(revision 39692f47bf3d5f4bad8b0c09ed47c6feaa8b3b7d)
+++ b/src/ch/epfl/tchu/gui/ServerMain.java	(date 1621608614091)
@@ -64,6 +64,8 @@
     @Override
     public void start(Stage primaryStage) throws IOException {
         ServerSocket serverSocket = new ServerSocket(5108);
+        //TODO 2 sockets
+
         Socket socket = serverSocket.accept();
         Socket socket2 = serverSocket.accept();
 
@@ -105,15 +107,18 @@
             Thread thread = new Thread(() ->{
                 String player1Name = GameMenu.getText1() == null ? "Ada" : GameMenu.getText1();
                 String player2Name = GameMenu.getText2() == null ? "Charles" : GameMenu.getText2();
+                String player3Name = "Joueur 3";
 
                 Map<PlayerId,String> playerNames = new EnumMap<>(PlayerId.class);
                 Map<PlayerId,Player> playerIdPlayerMap = new EnumMap<>(PlayerId.class);
 
                 playerNames.put(PlayerId.PLAYER_1,player1Name);
                 playerNames.put(PlayerId.PLAYER_2, player2Name);
+                playerNames.put(PlayerId.PLAYER_3, player3Name);
                 playerIdPlayerMap.put(PlayerId.PLAYER_1,new GraphicalPlayerAdapter());
                 playerIdPlayerMap.put(PlayerId.PLAYER_2,new RemotePlayerProxy(socket));
-                Game.play(playerIdPlayerMap, playerNames, SortedBag.of(ChMap.tickets()), new Random());
+                playerIdPlayerMap.put(PlayerId.PLAYER_3, new RemotePlayerProxy(socket2));
+                ThreePlayerGame.play(playerIdPlayerMap, playerNames, SortedBag.of(ChMap.tickets()), new Random());
                 //menu.hide();
             });
             thread.start();
Index: res/map.css
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Map */\r\n\r\nImageView {\r\n    -fx-image: url(\"map.png\");\r\n}\r\n\r\n.track {\r\n    -fx-stroke: dimgray;\r\n    -fx-stroke-width: 1;\r\n    -fx-stroke-type: outside;\r\n}\r\n\r\n.BLACK .track {\r\n    -fx-stroke: grey;\r\n}\r\n\r\n.UNDERGROUND .track {\r\n    -fx-stroke-dash-array: 8 4;\r\n    -fx-stroke-dash-offset: 4;\r\n    -fx-stroke-line-cap: butt;\r\n}\r\n\r\n.route:hover .track {\r\n    -fx-scale-x: 1.1;\r\n    -fx-scale-y: 1.1;\r\n}\r\n\r\n.car {\r\n    visibility: hidden;\r\n}\r\n\r\n.car Rectangle {\r\n    -fx-stroke-type: centered;\r\n    -fx-stroke: dimgrey;\r\n    -fx-stroke-width: 2;\r\n}\r\n\r\n.car Circle {\r\n    -fx-stroke-width: 1;\r\n    -fx-stroke: dimgrey;\r\n    -fx-fill: white;\r\n}\r\n\r\n.PLAYER_1 .car {\r\n    visibility: visible;\r\n}\r\n\r\n.PLAYER_2 .car {\r\n    visibility: visible;\r\n}\r\n\r\n/* Position of individual track segments */\r\n#BAD_BAL_1_1 { -fx-translate-x: 497; -fx-translate-y: 123; -fx-rotate: 27 }\r\n#BAD_BAL_1_2 { -fx-translate-x: 457; -fx-translate-y: 107; -fx-rotate: 17 }\r\n#BAD_BAL_1_3 { -fx-translate-x: 415; -fx-translate-y: 105; -fx-rotate: -8 }\r\n#BAD_OLT_1_1 { -fx-translate-x: 505; -fx-translate-y: 158; -fx-rotate: -30 }\r\n#BAD_OLT_1_2 { -fx-translate-x: 468; -fx-translate-y: 180; -fx-rotate: -30 }\r\n#BAD_ZUR_1_1 { -fx-translate-x: 560; -fx-translate-y: 156; -fx-rotate: 26 }\r\n#BAL_DE1_1_1 { -fx-translate-x: 382; -fx-translate-y: 79; -fx-rotate: -81 }\r\n#BAL_DEL_1_1 { -fx-translate-x: 357; -fx-translate-y: 143; -fx-rotate: -52 }\r\n#BAL_DEL_1_2 { -fx-translate-x: 325; -fx-translate-y: 170; -fx-rotate: -28 }\r\n#BAL_OLT_1_1 { -fx-translate-x: 393; -fx-translate-y: 148; -fx-rotate: -114 }\r\n#BAL_OLT_1_2 { -fx-translate-x: 419; -fx-translate-y: 182; -fx-rotate: -139 }\r\n#BEL_LOC_1_1 { -fx-translate-x: 700; -fx-translate-y: 596; -fx-rotate: -12 }\r\n#BEL_LUG_1_1 { -fx-translate-x: 725; -fx-translate-y: 622; -fx-rotate: -81 }\r\n#BEL_WAS_1_1 { -fx-translate-x: 705; -fx-translate-y: 564; -fx-rotate: -124 }\r\n#BEL_WAS_1_2 { -fx-translate-x: 682; -fx-translate-y: 530; -fx-rotate: -124 }\r\n#BEL_WAS_1_3 { -fx-translate-x: 659; -fx-translate-y: 494; -fx-rotate: -124 }\r\n#BEL_WAS_1_4 { -fx-translate-x: 636; -fx-translate-y: 460; -fx-rotate: -124 }\r\n#BER_FRI_1_1 { -fx-translate-x: 309; -fx-translate-y: 353; -fx-rotate: -40 }\r\n#BER_INT_1_3 { -fx-translate-x: 414; -fx-translate-y: 422; -fx-rotate: 12 }\r\n#BER_INT_1_2 { -fx-translate-x: 377; -fx-translate-y: 402; -fx-rotate: 45 }\r\n#BER_INT_1_1 { -fx-translate-x: 356; -fx-translate-y: 367; -fx-rotate: 69 }\r\n#BER_NEU_1_1 { -fx-translate-x: 302; -fx-translate-y: 323; -fx-rotate: 8 }\r\n#BER_NEU_1_2 { -fx-translate-x: 261; -fx-translate-y: 317; -fx-rotate: 8 }\r\n#BER_LUC_1_1 { -fx-translate-x: 382; -fx-translate-y: 328; -fx-rotate: 4 }\r\n#BER_LUC_1_2 { -fx-translate-x: 424; -fx-translate-y: 328; -fx-rotate: -8 }\r\n#BER_LUC_1_3 { -fx-translate-x: 465; -fx-translate-y: 320; -fx-rotate: -14 }\r\n#BER_LUC_1_4 { -fx-translate-x: 505; -fx-translate-y: 305; -fx-rotate: -24 }\r\n#BER_SOL_1_1 { -fx-translate-x: 352; -fx-translate-y: 292; -fx-rotate: -84 }\r\n#BER_SOL_1_2 { -fx-translate-x: 359; -fx-translate-y: 249; -fx-rotate: -84 }\r\n#BRI_IT5_1_1 { -fx-translate-x: 497; -fx-translate-y: 569; -fx-rotate: 56 }\r\n#BRI_IT5_1_2 { -fx-translate-x: 520; -fx-translate-y: 604; -fx-rotate: 56 }\r\n#BRI_IT5_1_3 { -fx-translate-x: 544; -fx-translate-y: 638; -fx-rotate: 56 }\r\n#BRI_INT_1_1 { -fx-translate-x: 453; -fx-translate-y: 505; -fx-rotate: -113 }\r\n#BRI_INT_1_2 { -fx-translate-x: 445; -fx-translate-y: 464; -fx-rotate: -89 }\r\n#BRI_LOC_1_1 { -fx-translate-x: 506; -fx-translate-y: 527; -fx-rotate: -20 }\r\n#BRI_LOC_1_2 { -fx-translate-x: 545; -fx-translate-y: 512; -fx-rotate: -20 }\r\n#BRI_LOC_1_3 { -fx-translate-x: 584; -fx-translate-y: 496; -fx-rotate: -20 }\r\n#BRI_LOC_1_4 { -fx-translate-x: 616; -fx-translate-y: 498; -fx-rotate: 66 }\r\n#BRI_LOC_1_5 { -fx-translate-x: 633; -fx-translate-y: 537; -fx-rotate: 66 }\r\n#BRI_LOC_1_6 { -fx-translate-x: 649; -fx-translate-y: 577; -fx-rotate: 66 }\r\n#BRI_SIO_1_1 { -fx-translate-x: 444; -fx-translate-y: 559; -fx-rotate: -29 }\r\n#BRI_SIO_1_2 { -fx-translate-x: 403; -fx-translate-y: 573; -fx-rotate: -7 }\r\n#BRI_SIO_1_3 { -fx-translate-x: 360; -fx-translate-y: 572; -fx-rotate: 8 }\r\n#BRI_WAS_1_1 { -fx-translate-x: 494; -fx-translate-y: 506; -fx-rotate: -33 }\r\n#BRI_WAS_1_2 { -fx-translate-x: 529; -fx-translate-y: 483; -fx-rotate: -33 }\r\n#BRI_WAS_1_3 { -fx-translate-x: 564; -fx-translate-y: 461; -fx-rotate: -33 }\r\n#BRI_WAS_1_4 { -fx-translate-x: 598; -fx-translate-y: 438; -fx-rotate: -33 }\r\n#BRU_COI_1_1 { -fx-translate-x: 949; -fx-translate-y: 535; -fx-rotate: 54 }\r\n#BRU_COI_1_2 { -fx-translate-x: 925; -fx-translate-y: 502; -fx-rotate: 54 }\r\n#BRU_COI_1_3 { -fx-translate-x: 901; -fx-translate-y: 468; -fx-rotate: 54 }\r\n#BRU_COI_1_4 { -fx-translate-x: 877; -fx-translate-y: 434; -fx-rotate: 54 }\r\n#BRU_COI_1_5 { -fx-translate-x: 852; -fx-translate-y: 400; -fx-rotate: 54 }\r\n#BRU_DAV_1_1 { -fx-translate-x: 975; -fx-translate-y: 525; -fx-rotate: 80 }\r\n#BRU_DAV_1_2 { -fx-translate-x: 968; -fx-translate-y: 484; -fx-rotate: 80 }\r\n#BRU_DAV_1_3 { -fx-translate-x: 961; -fx-translate-y: 444; -fx-rotate: 80 }\r\n#BRU_DAV_1_4 { -fx-translate-x: 954; -fx-translate-y: 404; -fx-rotate: 80 }\r\n#BRU_IT2_1_1 { -fx-translate-x: 995; -fx-translate-y: 589; -fx-rotate: 60 }\r\n#BRU_IT2_1_2 { -fx-translate-x: 1016; -fx-translate-y: 626; -fx-rotate: 60 }\r\n#COI_DAV_1_1 { -fx-translate-x: 871; -fx-translate-y: 368; -fx-rotate: 0 }\r\n#COI_DAV_1_2 { -fx-translate-x: 913; -fx-translate-y: 369; -fx-rotate: 0 }\r\n#COI_SAR_1_1 { -fx-translate-x: 820; -fx-translate-y: 336; -fx-rotate: 62 }\r\n#COI_WAS_1_1 { -fx-translate-x: 816; -fx-translate-y: 398; -fx-rotate: -54 }\r\n#COI_WAS_1_2 { -fx-translate-x: 788; -fx-translate-y: 429; -fx-rotate: -44 }\r\n#COI_WAS_1_3 { -fx-translate-x: 751; -fx-translate-y: 449; -fx-rotate: -16 }\r\n#COI_WAS_1_4 { -fx-translate-x: 710; -fx-translate-y: 449; -fx-rotate: 18 }\r\n#COI_WAS_1_5 { -fx-translate-x: 671; -fx-translate-y: 433; -fx-rotate: 30 }\r\n#DAV_IT1_1_1 { -fx-translate-x: 980; -fx-translate-y: 382; -fx-rotate: 10 }\r\n#DAV_IT1_1_2 { -fx-translate-x: 1021; -fx-translate-y: 389; -fx-rotate: 10 }\r\n#DAV_IT1_1_3 { -fx-translate-x: 1063; -fx-translate-y: 395; -fx-rotate: 10 }\r\n#DAV_AT3_1_1 { -fx-translate-x: 979; -fx-translate-y: 356; -fx-rotate: -17 }\r\n#DAV_AT3_1_2 { -fx-translate-x: 1020; -fx-translate-y: 342; -fx-rotate: -18 }\r\n#DAV_AT3_1_3 { -fx-translate-x: 1059; -fx-translate-y: 329; -fx-rotate: -18 }\r\n#DAV_SAR_1_1 { -fx-translate-x: 918; -fx-translate-y: 341; -fx-rotate: 37 }\r\n#DAV_SAR_1_2 { -fx-translate-x: 882; -fx-translate-y: 319; -fx-rotate: 30 }\r\n#DAV_SAR_1_3 { -fx-translate-x: 842; -fx-translate-y: 307; -fx-rotate: 3 }\r\n#DEL_FR4_1_1 { -fx-translate-x: 299; -fx-translate-y: 149; -fx-rotate: -83 }\r\n#DEL_FR4_1_2 { -fx-translate-x: 303; -fx-translate-y: 108; -fx-rotate: -83 }\r\n#DEL_LCF_1_1 { -fx-translate-x: 262; -fx-translate-y: 194; -fx-rotate: -18 }\r\n#DEL_LCF_1_2 { -fx-translate-x: 223; -fx-translate-y: 211; -fx-rotate: -28 }\r\n#DEL_LCF_1_3 { -fx-translate-x: 187; -fx-translate-y: 239; -fx-rotate: -52 }\r\n#DEL_SOL_1_1 { -fx-translate-x: 327; -fx-translate-y: 201; -fx-rotate: 18 }\r\n#DE2_SCE_1_1 { -fx-translate-x: 637; -fx-translate-y: 27; -fx-rotate: -28 }\r\n#DE3_KRE_1_1 { -fx-translate-x: 743; -fx-translate-y: 43; -fx-rotate: 60 }\r\n#DE4_KRE_1_1 { -fx-translate-x: 784; -fx-translate-y: 51; -fx-rotate: -43 }\r\n#DE5_STG_1_1 { -fx-translate-x: 859; -fx-translate-y: 103; -fx-rotate: -34 }\r\n#DE5_STG_1_2 { -fx-translate-x: 824; -fx-translate-y: 126; -fx-rotate: -34 }\r\n#FR1_MAR_1_1 { -fx-translate-x: 188; -fx-translate-y: 686; -fx-rotate: -48 }\r\n#FR1_MAR_1_2 { -fx-translate-x: 215; -fx-translate-y: 655; -fx-rotate: -48 }\r\n#FR2_GEN_1_1 { -fx-translate-x: 23; -fx-translate-y: 622; -fx-rotate: -80 }\r\n#FR3_LCF_1_1 { -fx-translate-x: 96; -fx-translate-y: 230; -fx-rotate: 28 }\r\n#FR3_LCF_1_2 { -fx-translate-x: 134; -fx-translate-y: 249; -fx-rotate: 28 }\r\n#FRI_LAU_1_1 { -fx-translate-x: 255; -fx-translate-y: 396; -fx-rotate: -36 }\r\n#FRI_LAU_1_2 { -fx-translate-x: 223; -fx-translate-y: 420; -fx-rotate: -36 }\r\n#FRI_LAU_1_3 { -fx-translate-x: 191; -fx-translate-y: 444; -fx-rotate: -36 }\r\n#GEN_LAU_1_1 { -fx-translate-x: 33; -fx-translate-y: 554; -fx-rotate: -77 }\r\n#GEN_LAU_1_2 { -fx-translate-x: 48; -fx-translate-y: 513; -fx-rotate: -65 }\r\n#GEN_LAU_1_3 { -fx-translate-x: 90; -fx-translate-y: 475; -fx-rotate: -18 }\r\n#GEN_LAU_1_4 { -fx-translate-x: 132; -fx-translate-y: 465; -fx-rotate: -9 }\r\n#GEN_YVE_1_1 { -fx-translate-x: 13; -fx-translate-y: 548; -fx-rotate: -94 }\r\n#GEN_YVE_1_2 { -fx-translate-x: 12; -fx-translate-y: 508; -fx-rotate: -93 }\r\n#GEN_YVE_1_3 { -fx-translate-x: 20; -fx-translate-y: 466; -fx-rotate: -68 }\r\n#GEN_YVE_1_4 { -fx-translate-x: 43; -fx-translate-y: 432; -fx-rotate: -45 }\r\n#GEN_YVE_1_5 { -fx-translate-x: 78; -fx-translate-y: 407; -fx-rotate: -25 }\r\n#GEN_YVE_1_6 { -fx-translate-x: 119; -fx-translate-y: 393; -fx-rotate: -11 }\r\n#INT_LUC_1_1 { -fx-translate-x: 479; -fx-translate-y: 426; -fx-rotate: -9 }\r\n#INT_LUC_1_2 { -fx-translate-x: 518; -fx-translate-y: 406; -fx-rotate: -44 }\r\n#INT_LUC_1_3 { -fx-translate-x: 542; -fx-translate-y: 373; -fx-rotate: -71 }\r\n#INT_LUC_1_4 { -fx-translate-x: 549; -fx-translate-y: 331; -fx-rotate: -94 }\r\n#IT3_LUG_1_1 { -fx-translate-x: 753; -fx-translate-y: 694; -fx-rotate: -12 }\r\n#IT3_LUG_1_2 { -fx-translate-x: 723; -fx-translate-y: 687; -fx-rotate: 79 }\r\n#IT4_LOC_1_1 { -fx-translate-x: 645; -fx-translate-y: 678; -fx-rotate: 105 }\r\n#IT4_LOC_1_2 { -fx-translate-x: 655; -fx-translate-y: 639; -fx-rotate: 105 }\r\n#KRE_SCE_1_1 { -fx-translate-x: 724; -fx-translate-y: 65; -fx-rotate: 24 }\r\n#KRE_SCE_1_2 { -fx-translate-x: 683; -fx-translate-y: 54; -fx-rotate: 8 }\r\n#KRE_SCE_1_3 { -fx-translate-x: 642; -fx-translate-y: 50; -fx-rotate: 3 }\r\n#KRE_STG_1_1 { -fx-translate-x: 778; -fx-translate-y: 110; -fx-rotate: 64 }\r\n#KRE_WIN_1_1 { -fx-translate-x: 722; -fx-translate-y: 94; -fx-rotate: -14 }\r\n#KRE_WIN_1_2 { -fx-translate-x: 681; -fx-translate-y: 104; -fx-rotate: -14 }\r\n#LCF_NEU_1_1 { -fx-translate-x: 192; -fx-translate-y: 291; -fx-rotate: 36 }\r\n#LCF_YVE_1_1 { -fx-translate-x: 141; -fx-translate-y: 284; -fx-rotate: -36 }\r\n#LCF_YVE_1_2 { -fx-translate-x: 117; -fx-translate-y: 319; -fx-rotate: -75 }\r\n#LCF_YVE_1_3 { -fx-translate-x: 126; -fx-translate-y: 359; -fx-rotate: -130 }\r\n#LAU_MAR_1_1 { -fx-translate-x: 193; -fx-translate-y: 489; -fx-rotate: 26 }\r\n#LAU_MAR_1_2 { -fx-translate-x: 226; -fx-translate-y: 514; -fx-rotate: 53 }\r\n#LAU_MAR_1_3 { -fx-translate-x: 242; -fx-translate-y: 553; -fx-rotate: 85 }\r\n#LAU_MAR_1_4 { -fx-translate-x: 241; -fx-translate-y: 595; -fx-rotate: 97 }\r\n#LAU_NEU_1_1 { -fx-translate-x: 170; -fx-translate-y: 427; -fx-rotate: -56 }\r\n#LAU_NEU_1_2 { -fx-translate-x: 200; -fx-translate-y: 395; -fx-rotate: -37 }\r\n#LAU_NEU_1_3 { -fx-translate-x: 236; -fx-translate-y: 373; -fx-rotate: -29 }\r\n#LAU_NEU_1_4 { -fx-translate-x: 234; -fx-translate-y: 341; -fx-rotate: 64 }\r\n#LOC_LUG_1_1 { -fx-translate-x: 690; -fx-translate-y: 628; -fx-rotate: 45 }\r\n#LUC_OLT_1_1 { -fx-translate-x: 511; -fx-translate-y: 282; -fx-rotate: -2 }\r\n#LUC_OLT_1_2 { -fx-translate-x: 471; -fx-translate-y: 269; -fx-rotate: 39 }\r\n#LUC_OLT_1_3 { -fx-translate-x: 449; -fx-translate-y: 232; -fx-rotate: 79 }\r\n#LUC_SCZ_1_1 { -fx-translate-x: 582; -fx-translate-y: 307; -fx-rotate: 17 }\r\n#LUC_ZOU_1_1 { -fx-translate-x: 561; -fx-translate-y: 260; -fx-rotate: -43 }\r\n#MAR_SIO_1_1 { -fx-translate-x: 273; -fx-translate-y: 615; -fx-rotate: -32 }\r\n#MAR_SIO_1_2 { -fx-translate-x: 305; -fx-translate-y: 589; -fx-rotate: -44 }\r\n#NEU_SOL_1_1 { -fx-translate-x: 224; -fx-translate-y: 282; -fx-rotate: -78 }\r\n#NEU_SOL_1_2 { -fx-translate-x: 245; -fx-translate-y: 244; -fx-rotate: -42 }\r\n#NEU_SOL_1_3 { -fx-translate-x: 283; -fx-translate-y: 225; -fx-rotate: -16 }\r\n#NEU_SOL_1_4 { -fx-translate-x: 325; -fx-translate-y: 221; -fx-rotate: 4 }\r\n#NEU_YVE_1_1 { -fx-translate-x: 189; -fx-translate-y: 324; -fx-rotate: -13 }\r\n#NEU_YVE_1_2 { -fx-translate-x: 163; -fx-translate-y: 354; -fx-rotate: -89 }\r\n#AT1_STG_1_1 { -fx-translate-x: 947; -fx-translate-y: 204; -fx-rotate: 20 }\r\n#AT1_STG_1_2 { -fx-translate-x: 908; -fx-translate-y: 190; -fx-rotate: 20 }\r\n#AT1_STG_1_3 { -fx-translate-x: 869; -fx-translate-y: 176; -fx-rotate: 20 }\r\n#AT1_STG_1_4 { -fx-translate-x: 830; -fx-translate-y: 162; -fx-rotate: 20 }\r\n#AT2_VAD_1_1 { -fx-translate-x: 883; -fx-translate-y: 245; -fx-rotate: -7 }\r\n#OLT_SOL_1_1 { -fx-translate-x: 399; -fx-translate-y: 213; -fx-rotate: -6 }\r\n#OLT_ZUR_1_1 { -fx-translate-x: 480; -fx-translate-y: 200; -fx-rotate: -11 }\r\n#OLT_ZUR_1_2 { -fx-translate-x: 522; -fx-translate-y: 192; -fx-rotate: -11 }\r\n#OLT_ZUR_1_3 { -fx-translate-x: 562; -fx-translate-y: 184; -fx-rotate: -11 }\r\n#PFA_SAR_1_1 { -fx-translate-x: 692; -fx-translate-y: 273; -fx-rotate: 56 }\r\n#PFA_SAR_1_2 { -fx-translate-x: 724; -fx-translate-y: 299; -fx-rotate: 24 }\r\n#PFA_SAR_1_3 { -fx-translate-x: 766; -fx-translate-y: 306; -fx-rotate: -1 }\r\n#PFA_SCZ_1_1 { -fx-translate-x: 651; -fx-translate-y: 280; -fx-rotate: 122 }\r\n#PFA_STG_1_1 { -fx-translate-x: 712; -fx-translate-y: 232; -fx-rotate: -20 }\r\n#PFA_STG_1_2 { -fx-translate-x: 751; -fx-translate-y: 214; -fx-rotate: -32 }\r\n#PFA_STG_1_3 { -fx-translate-x: 778; -fx-translate-y: 182; -fx-rotate: -66 }\r\n#PFA_ZUR_1_1 { -fx-translate-x: 666; -fx-translate-y: 216; -fx-rotate: 70 }\r\n#PFA_ZUR_1_2 { -fx-translate-x: 634; -fx-translate-y: 191; -fx-rotate: 6 }\r\n#SAR_VAD_1_1 { -fx-translate-x: 825; -fx-translate-y: 278; -fx-rotate: -51 }\r\n#SCE_WIN_1_1 { -fx-translate-x: 616; -fx-translate-y: 87; -fx-rotate: 66 }\r\n#SCE_ZUR_1_1 { -fx-translate-x: 581; -fx-translate-y: 59; -fx-rotate: -29 }\r\n#SCE_ZUR_1_2 { -fx-translate-x: 560; -fx-translate-y: 95; -fx-rotate: -89 }\r\n#SCE_ZUR_1_3 { -fx-translate-x: 575; -fx-translate-y: 135; -fx-rotate: -126 }\r\n#SCZ_WAS_1_1 { -fx-translate-x: 612; -fx-translate-y: 347; -fx-rotate: 92 }\r\n#SCZ_WAS_1_2 { -fx-translate-x: 612; -fx-translate-y: 388; -fx-rotate: 90 }\r\n#SCZ_ZOU_1_1 { -fx-translate-x: 606; -fx-translate-y: 281; -fx-rotate: 72 }\r\n#STG_VAD_1_1 { -fx-translate-x: 807; -fx-translate-y: 183; -fx-rotate: 63 }\r\n#STG_VAD_1_2 { -fx-translate-x: 826; -fx-translate-y: 220; -fx-rotate: 63 }\r\n#STG_WIN_1_1 { -fx-translate-x: 756; -fx-translate-y: 138; -fx-rotate: -2 }\r\n#STG_WIN_1_2 { -fx-translate-x: 715; -fx-translate-y: 140; -fx-rotate: -2 }\r\n#STG_WIN_1_3 { -fx-translate-x: 673; -fx-translate-y: 133; -fx-rotate: 26 }\r\n#STG_ZUR_1_1 { -fx-translate-x: 758; -fx-translate-y: 155; -fx-rotate: -7 }\r\n#STG_ZUR_1_2 { -fx-translate-x: 717; -fx-translate-y: 161; -fx-rotate: -7 }\r\n#STG_ZUR_1_3 { -fx-translate-x: 676; -fx-translate-y: 166; -fx-rotate: -7 }\r\n#STG_ZUR_1_4 { -fx-translate-x: 634; -fx-translate-y: 171; -fx-rotate: -7 }\r\n#WIN_ZUR_1_1 { -fx-translate-x: 611; -fx-translate-y: 134; -fx-rotate: -52 }\r\n#ZOU_ZUR_1_1 { -fx-translate-x: 589; -fx-translate-y: 214; -fx-rotate: -92 }\r\n#GEN_LAU_2_1 { -fx-translate-x: 49; -fx-translate-y: 559; -fx-rotate: -77 }\r\n#GEN_LAU_2_2 { -fx-translate-x: 64; -fx-translate-y: 518; -fx-rotate: -65 }\r\n#GEN_LAU_2_3 { -fx-translate-x: 95; -fx-translate-y: 490; -fx-rotate: -18 }\r\n#GEN_LAU_2_4 { -fx-translate-x: 136; -fx-translate-y: 480; -fx-rotate: -8 }\r\n#FRI_LAU_2_1 { -fx-translate-x: 265; -fx-translate-y: 408; -fx-rotate: -36 }\r\n#FRI_LAU_2_2 { -fx-translate-x: 233; -fx-translate-y: 432; -fx-rotate: -36 }\r\n#FRI_LAU_2_3 { -fx-translate-x: 201; -fx-translate-y: 456; -fx-rotate: -36 }\r\n#BER_FRI_2_1 { -fx-translate-x: 320; -fx-translate-y: 366; -fx-rotate: -40 }\r\n#BER_LUC_2_1 { -fx-translate-x: 385; -fx-translate-y: 344; -fx-rotate: 4 }\r\n#BER_LUC_2_2 { -fx-translate-x: 428; -fx-translate-y: 344; -fx-rotate: -9 }\r\n#BER_LUC_2_3 { -fx-translate-x: 468; -fx-translate-y: 336; -fx-rotate: -15 }\r\n#BER_LUC_2_4 { -fx-translate-x: 509; -fx-translate-y: 321; -fx-rotate: -24 }\r\n#LUC_ZOU_2_1 { -fx-translate-x: 572; -fx-translate-y: 271; -fx-rotate: -43 }\r\n#ZOU_ZUR_2_1 { -fx-translate-x: 604; -fx-translate-y: 214; -fx-rotate: -92 }\r\n#WIN_ZUR_2_1 { -fx-translate-x: 624; -fx-translate-y: 143; -fx-rotate: -52 }\r\n#SCE_WIN_2_1 { -fx-translate-x: 630; -fx-translate-y: 81; -fx-rotate: 66 }\r\n#SCZ_ZOU_2_1 { -fx-translate-x: 621; -fx-translate-y: 277; -fx-rotate: 72 }\r\n#SCZ_WAS_2_1 { -fx-translate-x: 629; -fx-translate-y: 348; -fx-rotate: 92 }\r\n#SCZ_WAS_2_2 { -fx-translate-x: 629; -fx-translate-y: 389; -fx-rotate: 91 }\r\n#BEL_WAS_2_1 { -fx-translate-x: 718; -fx-translate-y: 554; -fx-rotate: -124 }\r\n#BEL_WAS_2_2 { -fx-translate-x: 695; -fx-translate-y: 520; -fx-rotate: -124 }\r\n#BEL_WAS_2_3 { -fx-translate-x: 672; -fx-translate-y: 484; -fx-rotate: -124 }\r\n#BEL_WAS_2_4 { -fx-translate-x: 649; -fx-translate-y: 450; -fx-rotate: -124 }\r\n#BEL_LUG_2_1 { -fx-translate-x: 741; -fx-translate-y: 625; -fx-rotate: -81 }\r\n\r\n/* Local Variables: */\r\n/* css-fontify-colors: nil */\r\n/* End: */\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/res/map.css b/res/map.css
--- a/res/map.css	(revision 0d6e3e4ed90733c97b4f733f9fe6c9f845d4f267)
+++ b/res/map.css	(date 1621606965106)
@@ -49,6 +49,10 @@
     visibility: visible;
 }
 
+.PLAYER_3 .car {
+    visibility: visible;
+}
+
 /* Position of individual track segments */
 #BAD_BAL_1_1 { -fx-translate-x: 497; -fx-translate-y: 123; -fx-rotate: 27 }
 #BAD_BAL_1_2 { -fx-translate-x: 457; -fx-translate-y: 107; -fx-rotate: 17 }
Index: src/ch/epfl/tchu/game/PlayerId.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ch.epfl.tchu.game;\r\n\r\nimport java.util.List;\r\n\r\n/**\r\n * Le type énuméré PlayerId représente l'identité d'un joueur.\r\n *\r\n * @author Shangeeth Poobalasingam (329307)\r\n * @author Marvin Koch (324448)\r\n */\r\npublic enum PlayerId {\r\n    PLAYER_1,\r\n    PLAYER_2,\r\n    PLAYER_3;\r\n\r\n    /**\r\n     * Retourne une liste de tout les joueurs\r\n     */\r\n    public static final List<PlayerId> ALL = List.of(PlayerId.values());\r\n\r\n    /**\r\n     * Retourne le nombre de joueur\r\n     */\r\n    public static final int COUNT = ALL.size();\r\n\r\n    /**\r\n     * retourne l'identité du joueur qui suit celui auquel on l'applique, c-à-d PLAYER_2 pour PLAYER_1, et PLAYER_1 pour PLAYER_2\r\n     * @return PlayerId\r\n     */\r\n    public PlayerId next(){\r\n        return this.equals(PLAYER_1) ? PLAYER_2 : PLAYER_1;\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ch/epfl/tchu/game/PlayerId.java b/src/ch/epfl/tchu/game/PlayerId.java
--- a/src/ch/epfl/tchu/game/PlayerId.java	(revision 39692f47bf3d5f4bad8b0c09ed47c6feaa8b3b7d)
+++ b/src/ch/epfl/tchu/game/PlayerId.java	(date 1621608423746)
@@ -1,5 +1,7 @@
 package ch.epfl.tchu.game;
 
+import ch.epfl.tchu.gui.ServerMain;
+
 import java.util.List;
 
 /**
@@ -16,7 +18,7 @@
     /**
      * Retourne une liste de tout les joueurs
      */
-    public static final List<PlayerId> ALL = List.of(PlayerId.values());
+    public static final List<PlayerId> ALL = ServerMain.is3Player ? List.of(PlayerId.values()) : List.of(PlayerId.values()).subList(0, 3);
 
     /**
      * Retourne le nombre de joueur
@@ -28,7 +30,19 @@
      * @return PlayerId
      */
     public PlayerId next(){
-        return this.equals(PLAYER_1) ? PLAYER_2 : PLAYER_1;
+        //return this.equals(PLAYER_1) ? PLAYER_2 : PLAYER_1;
+        if(this.equals(PLAYER_1)){
+            return PLAYER_2;
+        }else if(this.equals(PLAYER_2)){
+            return PLAYER_3;
+        }else{
+            return PLAYER_1;
+        }
     }
+
+    public PlayerId doubleNext(){
+        return next().next();
+    }
+
 }
 
Index: src/ch/epfl/tchu/gui/ObservableGameState.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ch.epfl.tchu.gui;\r\n\r\nimport ch.epfl.tchu.Preconditions;\r\nimport ch.epfl.tchu.SortedBag;\r\nimport ch.epfl.tchu.game.*;\r\nimport javafx.beans.InvalidationListener;\r\nimport javafx.beans.property.*;\r\nimport javafx.beans.value.ChangeListener;\r\nimport javafx.beans.value.ObservableValue;\r\nimport javafx.collections.FXCollections;\r\nimport javafx.collections.ObservableList;\r\nimport javafx.util.Pair;\r\n\r\nimport java.util.*;\r\nimport java.util.stream.Collectors;\r\n\r\n/**\r\n * La classe ObservableGameState, finale, représante l'état observable de la partie\r\n *\r\n * @author Shangeeth Poobalasingam (329307)\r\n * @author Marvin Koch (324448)\r\n */\r\npublic final class ObservableGameState {\r\n    private final PlayerId id;\r\n    private PublicGameState publicGameState;\r\n    private PlayerState playerState;\r\n\r\n    //Propriétés de PublicGameState\r\n    private final IntegerProperty ticketPourcentage;\r\n    private final IntegerProperty cartePourcentage;\r\n    private final List<ObjectProperty<Card>> faceUpCards;\r\n    private final Map<Route, ObjectProperty<PlayerId>> routesProperties = new HashMap<>();\r\n\r\n    //Propriétés publics des PlayerStates\r\n    private final IntegerProperty player1TicketCount;\r\n    private final IntegerProperty player2TicketCount;\r\n    private final IntegerProperty player1CardCount;\r\n    private final IntegerProperty player2CardCount;\r\n    private final IntegerProperty player1WagonCount;\r\n    private final IntegerProperty player2WagonCount;\r\n    private final IntegerProperty player1PointsCount;\r\n    private final IntegerProperty player2PointsCount;\r\n\r\n    //Propriétés de privées de PlayerState\r\n    private final ObservableList<Ticket> playerTicketsList;\r\n    private final Map<Card, IntegerProperty> cardsCountMap = new HashMap<>();\r\n    private final Map<Route, BooleanProperty> routeStatusMap = new HashMap<>();\r\n\r\n    private static final Map<Route,Route> ROUTE_PAIRS = routeSister();\r\n    /**\r\n     * Crée 5 propriétés vide\r\n     * @return List de ObjectProperty\r\n     */\r\n    private static List<ObjectProperty<Card>> createFaceUpCards(){\r\n        List<ObjectProperty<Card>> faceUpCardProperties = new ArrayList<>();\r\n        for(int slot : Constants.FACE_UP_CARD_SLOTS){\r\n            faceUpCardProperties.add(new SimpleObjectProperty<>());\r\n        }\r\n        return faceUpCardProperties;\r\n    }\r\n\r\n    /**\r\n     * Map toutes les route voisine dans le jeu\r\n     * @return\r\n     */\r\n    private static Map<Route, Route> routeSister(){\r\n        Map<Route, Route> routeMapToSister = new HashMap<>();\r\n        for(Route route1 : ChMap.routes()){\r\n            ChMap.routes().stream().filter(route2 -> route1.station1() == route2.station1() && route1.station2() == route2.station2() && (!route1.id().equals(route2.id())))\r\n                    .findAny()\r\n                    .ifPresent(sister -> routeMapToSister.put(route1, sister));\r\n        }\r\n        return routeMapToSister;\r\n    }\r\n\r\n    /**\r\n     * Constructeur de ObservableGameState\r\n     * @param id PlayerId\r\n     */\r\n    public ObservableGameState(PlayerId id) {\r\n        this.id = id;\r\n        publicGameState = null;\r\n        playerState = null;\r\n\r\n        ticketPourcentage = new SimpleIntegerProperty(0);\r\n        cartePourcentage = new SimpleIntegerProperty(0);\r\n        faceUpCards = createFaceUpCards();\r\n        ChMap.routes().forEach(route -> routesProperties.put(route, new SimpleObjectProperty<>(null)));\r\n\r\n        player1TicketCount = new SimpleIntegerProperty(0);\r\n        player2TicketCount = new SimpleIntegerProperty(0);\r\n        player1CardCount = new SimpleIntegerProperty(0);\r\n        player2CardCount = new SimpleIntegerProperty(0);\r\n        player1WagonCount = new SimpleIntegerProperty(0);\r\n        player2WagonCount = new SimpleIntegerProperty(0);\r\n        player1PointsCount = new SimpleIntegerProperty(0);\r\n        player2PointsCount = new SimpleIntegerProperty(0);\r\n\r\n        playerTicketsList = FXCollections.observableList(new ArrayList<>());\r\n        Card.ALL.forEach(card -> cardsCountMap.put(card, new SimpleIntegerProperty(0)));\r\n        ChMap.routes().forEach(\r\n                route -> routeStatusMap.put(route, new SimpleBooleanProperty(false)));\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * Met à jour les propriétés de la classe\r\n     * @param gs la partie publique du jeu\r\n     * @param ps l'état du joueur\r\n     */\r\n    public void setState(PublicGameState gs, PlayerState ps){\r\n        publicGameState = gs;\r\n        playerState = ps;\r\n        ticketPourcentage.set((int)(gs.ticketsCount() / (double)ChMap.tickets().size()*100));\r\n        cartePourcentage.set((int)(gs.cardState().deckSize() / (double)Constants.TOTAL_CARDS_COUNT*100));\r\n\r\n        for (int slot : Constants.FACE_UP_CARD_SLOTS) {\r\n            Card newCard = gs.cardState().faceUpCard(slot);\r\n            faceUpCards.get(slot).set(newCard);\r\n        }\r\n\r\n        ps.routes().forEach(route -> routesProperties.get(route).set(id));\r\n        gs.playerState(id.next()).routes().forEach(route -> routesProperties.get(route).set(id.next()));\r\n\r\n        player1TicketCount.set(ps.ticketCount());\r\n        player2TicketCount.set(gs.playerState(id.next()).ticketCount());\r\n\r\n        player1CardCount.set(ps.cardCount());\r\n        player2CardCount.set(gs.playerState(id.next()).cardCount());\r\n\r\n        player1WagonCount.set(ps.carCount());\r\n        player2WagonCount.set(gs.playerState(id.next()).carCount());\r\n\r\n        player1PointsCount.set(ps.claimPoints());\r\n        player2PointsCount.set(gs.playerState(id.next()).claimPoints());\r\n\r\n        playerTicketsList.setAll(ps.tickets().toList());\r\n\r\n        Card.ALL.forEach(card -> cardsCountMap.get(card).set(ps.cards().countOf(card)));\r\n\r\n        for (Route route: routeStatusMap.keySet()) {\r\n            boolean hasASister = ROUTE_PAIRS.containsKey(route);\r\n            //le joueur est le joueur courant,\r\n            //la route n'appartient à personne et, dans le cas d'une route double, sa voisine non plus,\r\n            //le joueur a les wagons et les cartes nécessaires pour s'emparer de la route—ou en tout cas tenter de le faire s'il s'agit d'un tunnel.\r\n            routeStatusMap.get(route).set(id == publicGameState.currentPlayerId() && routesProperties.get(route).get() == null && ps.canClaimRoute(route) && (!hasASister || routesProperties.get(ROUTE_PAIRS.get(route)).get() == null));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retourne le pourcentage de billets restants\r\n     * @return ticketPercentage Property\r\n     */\r\n    public ReadOnlyIntegerProperty ticketPourcentageProperty() {\r\n        return ticketPourcentage;\r\n    }\r\n\r\n    /**\r\n     * Retourne le pourcentage de cartes restants\r\n     * @return carte Pourcentage Property\r\n     */\r\n    public ReadOnlyIntegerProperty cartePourcentageProperty() {\r\n        return cartePourcentage;\r\n    }\r\n\r\n    /**\r\n     * Retourne la carte voulue de FaceUpCards\r\n     * @param slot index désirée\r\n     * @return Object Property Card\r\n     */\r\n    public ReadOnlyObjectProperty<Card> getFaceUpCards(int slot) {\r\n        return faceUpCards.get(slot);\r\n    }\r\n\r\n    /**\r\n     * Retourne le PlayerId d'une Route\r\n     * @param route route désirée\r\n     * @return Object Property Playerid (contient null si elle n'a pas de propriétaire)\r\n     */\r\n    public ReadOnlyObjectProperty<PlayerId> getRoutePlayerIdProperty(Route route) {\r\n        return routesProperties.get(route);\r\n    }\r\n\r\n    /**\r\n     * Retourne les nombres de billets du PlayerId en argument\r\n     * @param id PlayerId\r\n     * @return Integer Property\r\n     */\r\n    public ReadOnlyIntegerProperty playerTicketCountProperty(PlayerId id){\r\n        return id == PlayerId.PLAYER_1 ? player1TicketCount : player2TicketCount;\r\n    }\r\n\r\n    /**\r\n     * Retourne les nombres de cartes du PlayerId\r\n     * @param id PlayerId\r\n     * @return Integer Property\r\n     */\r\n\r\n    public ReadOnlyIntegerProperty playerCardCountProperty(PlayerId id){\r\n        return id == PlayerId.PLAYER_1 ? player1CardCount : player2CardCount;\r\n    }\r\n\r\n    /**\r\n     * Retourne les nombres de wagons du PlayerId en argument\r\n     * @param id PlayerId\r\n     * @return Integer Property\r\n     */\r\n    public ReadOnlyIntegerProperty playerWagonCountProperty(PlayerId id){\r\n        return id == PlayerId.PLAYER_1 ? player1WagonCount : player2WagonCount;\r\n    }\r\n\r\n    /**\r\n     * Retourne les nombres de points du PlayerId en argument\r\n     * @param id PlayerId\r\n     * @return Integer Property\r\n     */\r\n    public ReadOnlyIntegerProperty playerPointCountProperty(PlayerId id){\r\n       return id == PlayerId.PLAYER_1 ? player1PointsCount : player2PointsCount;\r\n    }\r\n\r\n    /**\r\n     * Retourne les billets du playerState\r\n     * @return Observable List des billets\r\n     */\r\n    public ObservableList<Ticket> getPlayerTicketsList() {\r\n        return playerTicketsList;\r\n    }\r\n\r\n    /**\r\n     * Retourne le nombre de cartes de couleur choisi que le joueur possède\r\n     * @param card la carte désirée\r\n     * @return Integer Property du nombre\r\n     */\r\n    public ReadOnlyIntegerProperty getCardProperty(Card card) {\r\n        return cardsCountMap.get(card);\r\n    }\r\n\r\n    /**\r\n     * Retourne le status de la route càd si la route peut être prise ou pas par le joueur\r\n     * @param route la route désirée\r\n     * @return Boolean Property\r\n     */\r\n    public ReadOnlyBooleanProperty getRouteBooleanProperty(Route route) {\r\n        return routeStatusMap.get(route);\r\n    }\r\n\r\n    /**\r\n     * Retourne la méthode canDrawCards() du game state\r\n     * @return boolean\r\n     */\r\n    public boolean canDrawCards(){\r\n        return publicGameState.canDrawCards();\r\n    }\r\n\r\n    /**\r\n     * Retourne la méthode canDrawTickets() du game state\r\n     * @return boolean\r\n     */\r\n    public boolean canDrawTickets(){\r\n        return publicGameState.canDrawTickets();\r\n    }\r\n\r\n    /**\r\n     * Retourne la méthode possibleClaimCards du playerState\r\n     * @param route la route désirée\r\n     * @return une list des multiensemble de cartes permettant le joueur de s'emparer de la route voulue\r\n     */\r\n    public List<SortedBag<Card>> possibleClaimCards(Route route){\r\n        return List.copyOf(playerState.possibleClaimCards(route));\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ch/epfl/tchu/gui/ObservableGameState.java b/src/ch/epfl/tchu/gui/ObservableGameState.java
--- a/src/ch/epfl/tchu/gui/ObservableGameState.java	(revision 39692f47bf3d5f4bad8b0c09ed47c6feaa8b3b7d)
+++ b/src/ch/epfl/tchu/gui/ObservableGameState.java	(date 1621609751487)
@@ -32,14 +32,10 @@
     private final Map<Route, ObjectProperty<PlayerId>> routesProperties = new HashMap<>();
 
     //Propriétés publics des PlayerStates
-    private final IntegerProperty player1TicketCount;
-    private final IntegerProperty player2TicketCount;
-    private final IntegerProperty player1CardCount;
-    private final IntegerProperty player2CardCount;
-    private final IntegerProperty player1WagonCount;
-    private final IntegerProperty player2WagonCount;
-    private final IntegerProperty player1PointsCount;
-    private final IntegerProperty player2PointsCount;
+    private final Map<PlayerId, IntegerProperty> playerTicketCount = new HashMap<>();
+    private final Map<PlayerId, IntegerProperty> playerCardCount = new HashMap<>();
+    private final Map<PlayerId, IntegerProperty> playerWagonCount = new HashMap<>();
+    private final Map<PlayerId, IntegerProperty> playerPointsCount = new HashMap<>();
 
     //Propriétés de privées de PlayerState
     private final ObservableList<Ticket> playerTicketsList;
@@ -87,14 +83,10 @@
         faceUpCards = createFaceUpCards();
         ChMap.routes().forEach(route -> routesProperties.put(route, new SimpleObjectProperty<>(null)));
 
-        player1TicketCount = new SimpleIntegerProperty(0);
-        player2TicketCount = new SimpleIntegerProperty(0);
-        player1CardCount = new SimpleIntegerProperty(0);
-        player2CardCount = new SimpleIntegerProperty(0);
-        player1WagonCount = new SimpleIntegerProperty(0);
-        player2WagonCount = new SimpleIntegerProperty(0);
-        player1PointsCount = new SimpleIntegerProperty(0);
-        player2PointsCount = new SimpleIntegerProperty(0);
+        PlayerId.ALL.forEach(playerId -> playerTicketCount.put(playerId, new SimpleIntegerProperty(0)));
+        PlayerId.ALL.forEach(playerId -> playerCardCount.put(playerId, new SimpleIntegerProperty(0)));
+        PlayerId.ALL.forEach(playerId -> playerWagonCount.put(playerId, new SimpleIntegerProperty(0)));
+        PlayerId.ALL.forEach(playerId -> playerPointsCount.put(playerId, new SimpleIntegerProperty(0)));
 
         playerTicketsList = FXCollections.observableList(new ArrayList<>());
         Card.ALL.forEach(card -> cardsCountMap.put(card, new SimpleIntegerProperty(0)));
@@ -122,7 +114,9 @@
 
         ps.routes().forEach(route -> routesProperties.get(route).set(id));
         gs.playerState(id.next()).routes().forEach(route -> routesProperties.get(route).set(id.next()));
+        gs.playerState(id.doubleNext()).routes().forEach(route -> routesProperties.get(route).set(id.doubleNext()));
 
+        /*
         player1TicketCount.set(ps.ticketCount());
         player2TicketCount.set(gs.playerState(id.next()).ticketCount());
 
@@ -135,6 +129,12 @@
         player1PointsCount.set(ps.claimPoints());
         player2PointsCount.set(gs.playerState(id.next()).claimPoints());
 
+         */
+        playerTicketCount.forEach((playerId, integerProperty) -> integerProperty.set((gs.playerState(playerId).ticketCount())));
+        playerCardCount.forEach((playerId, integerProperty) -> integerProperty.set(gs.playerState(playerId).cardCount()));
+        playerCardCount.forEach((playerId, integerProperty) -> integerProperty.set(gs.playerState(playerId).carCount()));
+        playerCardCount.forEach((playerId, integerProperty) -> integerProperty.set(gs.playerState(playerId).claimPoints()));
+
         playerTicketsList.setAll(ps.tickets().toList());
 
         Card.ALL.forEach(card -> cardsCountMap.get(card).set(ps.cards().countOf(card)));
@@ -144,7 +144,9 @@
             //le joueur est le joueur courant,
             //la route n'appartient à personne et, dans le cas d'une route double, sa voisine non plus,
             //le joueur a les wagons et les cartes nécessaires pour s'emparer de la route—ou en tout cas tenter de le faire s'il s'agit d'un tunnel.
-            routeStatusMap.get(route).set(id == publicGameState.currentPlayerId() && routesProperties.get(route).get() == null && ps.canClaimRoute(route) && (!hasASister || routesProperties.get(ROUTE_PAIRS.get(route)).get() == null));
+
+            routeStatusMap.get(route).set(id == publicGameState.currentPlayerId() && routesProperties.get(route).get() == null && ps.canClaimRoute(route)
+                    && (!hasASister || ServerMain.is3Player ? routesProperties.get(ROUTE_PAIRS.get(route)).get() != id :  routesProperties.get(ROUTE_PAIRS.get(route)).get() == null));
         }
     }
 
@@ -188,7 +190,7 @@
      * @return Integer Property
      */
     public ReadOnlyIntegerProperty playerTicketCountProperty(PlayerId id){
-        return id == PlayerId.PLAYER_1 ? player1TicketCount : player2TicketCount;
+        return playerTicketCount.get(id);
     }
 
     /**
@@ -198,7 +200,7 @@
      */
 
     public ReadOnlyIntegerProperty playerCardCountProperty(PlayerId id){
-        return id == PlayerId.PLAYER_1 ? player1CardCount : player2CardCount;
+        return playerCardCount.get(id);
     }
 
     /**
@@ -207,7 +209,7 @@
      * @return Integer Property
      */
     public ReadOnlyIntegerProperty playerWagonCountProperty(PlayerId id){
-        return id == PlayerId.PLAYER_1 ? player1WagonCount : player2WagonCount;
+        return playerWagonCount.get(id);
     }
 
     /**
@@ -216,7 +218,7 @@
      * @return Integer Property
      */
     public ReadOnlyIntegerProperty playerPointCountProperty(PlayerId id){
-       return id == PlayerId.PLAYER_1 ? player1PointsCount : player2PointsCount;
+        return playerPointsCount.get(id);
     }
 
     /**
Index: src/ch/epfl/tchu/game/PublicGameState.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ch.epfl.tchu.game;\r\n\r\nimport ch.epfl.tchu.Preconditions;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Objects;\r\n\r\n/**\r\n * La classe PublicGameState publique et immuable, représente la partie publique de l'état d'une partie de tCHu.\r\n * @author Shangeeth Poobalasingam (329307)\r\n * @author Marvin Koch (324448)\r\n */\r\n\r\npublic class PublicGameState {\r\n    private final int MINIMUM_CARDS_COUNT = 5;\r\n    final private int ticketsCount;\r\n    final private PublicCardState cardState;\r\n    final private PlayerId currentPlayerId;\r\n    final private Map<PlayerId, PublicPlayerState> playerState;\r\n    final private PlayerId lastPlayer;\r\n\r\n    /**\r\n     * Construit la partie publique de l'état d'une partie de tCHu dans laquelle la pioche de billets a une taille de ticketsCount,\r\n     * l'état public des cartes wagon/locomotive est cardState, le joueur courant est currentPlayerId,\r\n     * l'état public des joueurs est contenu dans playerState,\r\n     * et l'identité du dernier joueur est lastPlayer (qui peut être null si cette identité est encore inconnue)\r\n     * @param ticketsCount taille de la pioche\r\n     * @param cardState  l'état public des cartes wagon/locomotive\r\n     * @param currentPlayerId le joueur courant\r\n     * @param playerState l'état public des joueurs\r\n     * @param lastPlayer l'identité du dernier joueur\r\n     * @throws IllegalArgumentException si la taille de la pioche est strictement négative ou si playerState ne contient pas exactement deux paires clef/valeur,\r\n     * @throws  NullPointerException si l'un des autres arguments (lastPlayer excepté!) est nul\r\n     */\r\n    public PublicGameState(int ticketsCount, PublicCardState cardState, PlayerId currentPlayerId, Map<PlayerId, PublicPlayerState> playerState, PlayerId lastPlayer){\r\n        Preconditions.checkArgument(ticketsCount >= 0 && playerState.size() == PlayerId.COUNT);\r\n        this.ticketsCount = ticketsCount;\r\n        this.cardState = Objects.requireNonNull(cardState);\r\n        this.currentPlayerId = Objects.requireNonNull(currentPlayerId) ;\r\n        this.playerState = Map.copyOf(playerState);\r\n        this.lastPlayer = lastPlayer;\r\n    }\r\n\r\n    /**\r\n     * retourne la taille de la pioche de billets\r\n     * @return taille de la pioche\r\n     */\r\n    public int ticketsCount(){\r\n        return ticketsCount;\r\n    }\r\n\r\n    /**\r\n     * retourne vrai ssi il est possible de tirer des billets, c-à-d si la pioche n'est pas vide\r\n     * @return si poche non vide\r\n     */\r\n    public boolean canDrawTickets(){\r\n        return ticketsCount()!= 0;\r\n    }\r\n\r\n\r\n    /**\r\n     * Retourne la partie publique de l'état des cartes wagon/locomotive\r\n     * @return cardState\r\n     */\r\n    public PublicCardState cardState(){\r\n        return cardState;\r\n    }\r\n\r\n    /**\r\n     * Retourne vrai ssi il est possible de tirer des cartes, c-à-d si la pioche et la défausse contiennent entre elles au moins 5 cartes\r\n     * @return pioche + defausse >= 5\r\n     */\r\n    public boolean canDrawCards(){\r\n        return cardState().deckSize() + cardState().discardsSize() >= MINIMUM_CARDS_COUNT;\r\n    }\r\n\r\n    /**\r\n     * Retourne l'identité du joueur actuel\r\n     * @return currentPlayer\r\n     */\r\n    public PlayerId currentPlayerId(){\r\n        return currentPlayerId;\r\n    }\r\n\r\n    /**\r\n     * Retourne la partie publique de l'état du joueur d'identité donnée\r\n     * @param playerId id du joueurs\r\n     * @return PublicPlayerState de playerId\r\n     */\r\n    public PublicPlayerState playerState(PlayerId playerId){\r\n        return playerState.get(playerId);\r\n    }\r\n\r\n    /**\r\n     * Retourne la partie publique de l'état du joueur courant\r\n     * @return PublicPlayerState de currentPlayer\r\n     */\r\n    public PublicPlayerState currentPlayerState(){\r\n        return playerState.get(currentPlayerId());\r\n    }\r\n\r\n    /**\r\n     * Retourne la totalité des routes dont l'un ou l'autre des joueurs s'est emparé\r\n     * @return liste\r\n     */\r\n    public List<Route> claimedRoutes(){\r\n        List<Route> routeList = new ArrayList<>();\r\n        PlayerId.ALL.forEach(id -> routeList.addAll(playerState(id).routes()));\r\n        return routeList;\r\n    }\r\n\r\n\r\n    /**\r\n     * Retourne l'identité du dernier joueur, ou null si elle n'est pas encore connue car le dernier tour n'a pas commencé.\r\n     * @return PlayerId du lastplayer\r\n     */\r\n    public PlayerId lastPlayer(){\r\n        return lastPlayer;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ch/epfl/tchu/game/PublicGameState.java b/src/ch/epfl/tchu/game/PublicGameState.java
--- a/src/ch/epfl/tchu/game/PublicGameState.java	(revision 39692f47bf3d5f4bad8b0c09ed47c6feaa8b3b7d)
+++ b/src/ch/epfl/tchu/game/PublicGameState.java	(date 1621604461795)
@@ -104,6 +104,7 @@
      * Retourne la totalité des routes dont l'un ou l'autre des joueurs s'est emparé
      * @return liste
      */
+    //TODO 3 Player
     public List<Route> claimedRoutes(){
         List<Route> routeList = new ArrayList<>();
         PlayerId.ALL.forEach(id -> routeList.addAll(playerState(id).routes()));
Index: src/ch/epfl/tchu/gui/GraphicalPlayer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ch.epfl.tchu.gui;\r\n\r\nimport ch.epfl.tchu.Preconditions;\r\nimport ch.epfl.tchu.SortedBag;\r\nimport ch.epfl.tchu.game.*;\r\nimport javafx.beans.binding.Bindings;\r\nimport javafx.beans.property.ObjectProperty;\r\nimport javafx.beans.property.SimpleObjectProperty;\r\nimport javafx.collections.FXCollections;\r\nimport javafx.collections.ObservableList;\r\nimport javafx.event.Event;\r\nimport javafx.scene.Node;\r\nimport javafx.scene.Scene;\r\nimport javafx.scene.control.Button;\r\nimport javafx.scene.control.ListView;\r\nimport javafx.scene.control.SelectionMode;\r\nimport javafx.scene.control.cell.TextFieldListCell;\r\nimport javafx.scene.layout.BorderPane;\r\nimport javafx.scene.layout.HBox;\r\nimport javafx.scene.layout.Pane;\r\nimport javafx.scene.layout.VBox;\r\nimport javafx.scene.paint.Color;\r\nimport javafx.scene.text.Font;\r\nimport javafx.scene.text.Text;\r\nimport javafx.scene.text.TextFlow;\r\nimport javafx.stage.Modality;\r\nimport javafx.stage.Stage;\r\nimport javafx.stage.StageStyle;\r\nimport javafx.util.StringConverter;\r\n\r\nimport static ch.epfl.tchu.gui.ActionHandlers.*;\r\nimport static ch.epfl.tchu.gui.StringsFr.*;\r\nimport static javafx.application.Platform.isFxApplicationThread;\r\nimport static javafx.application.Platform.runLater;\r\n\r\nimport java.util.*;\r\nimport java.util.stream.Collectors;\r\n\r\n/**\r\n * La classe GraphicalPlayer, finale, représente l'interface graphique d'un joueur\r\n *\r\n * @author Shangeeth Poobalasingam (329307)\r\n * @author Marvin Koch (324448)\r\n */\r\npublic final class GraphicalPlayer{\r\n    private final ObservableList<Text> infos;\r\n    private final ObservableGameState observableGameState;\r\n    private final ObjectProperty<DrawTicketsHandler> drawTicketsHandlerProperty;\r\n    private final ObjectProperty<DrawCardHandler> drawCardHandlerProperty;\r\n    private final ObjectProperty<ClaimRouteHandler> drawClaimRouteHandlerProperty;\r\n    private final Stage mainStage;\r\n\r\n    /**\r\n     * Constructeur de GraphicalPlayer\r\n     * @param id PlayerId\r\n     * @param namesMap noms des joueurs\r\n     */\r\n    public GraphicalPlayer(PlayerId id, Map<PlayerId, String> namesMap){\r\n        assert isFxApplicationThread();\r\n        observableGameState = new ObservableGameState(id);\r\n        infos = FXCollections.observableList(new ArrayList<>());\r\n        drawTicketsHandlerProperty = new SimpleObjectProperty<>();\r\n        drawCardHandlerProperty = new SimpleObjectProperty<>();\r\n        drawClaimRouteHandlerProperty = new SimpleObjectProperty<>();\r\n        mainStage = new Stage();\r\n        mainStage.setTitle(String.format(\"%s \\u2014 %s\",\"tCHu\", namesMap.get(id)));\r\n        BorderPane pane = new BorderPane(MapViewCreator.createMapView(observableGameState, drawClaimRouteHandlerProperty, this::chooseClaimCards),\r\n                null,\r\n                DecksViewCreator.createCardsView(observableGameState, drawTicketsHandlerProperty, drawCardHandlerProperty),\r\n                DecksViewCreator.createHandView(observableGameState),\r\n                InfoViewCreator.createInfoView(id,namesMap,observableGameState,infos));\r\n        Scene scene = new Scene(pane);\r\n        mainStage.setScene(scene);\r\n        mainStage.show();\r\n    }\r\n    \r\n\r\n    /**\r\n     * Méthode prenant les mêmes arguments que la méthode setState de ObservableGameState\r\n     * et ne faisant rien d'autre que d'appeler cette méthode sur l'état observable du joueur\r\n     * @param gs un PublicGameState\r\n     * @param ps un PlayerState\r\n     */\r\n    public void setState(PublicGameState gs, PlayerState ps){\r\n        assert isFxApplicationThread();\r\n        observableGameState.setState(gs, ps);\r\n    }\r\n\r\n    /**\r\n     * Méthode prenant un message - de type String —\r\n     * et l'ajoutant au bas des informations sur le déroulement de la partie,\r\n     * qui sont présentées dans la partie inférieure de la vue des informations\r\n     * @param s info\r\n     */\r\n    public void receiveInfo(String s){\r\n        assert isFxApplicationThread();\r\n        Preconditions.checkArgument(infos.size()<=5);\r\n        Text text = new Text(s);\r\n        if(infos.size() == 5)\r\n            infos.remove(0);\r\n        infos.add(text);\r\n    }\r\n\r\n    /**\r\n     * Méthode qui prend en arguments trois gestionnaires d'action,\r\n     * un par types d'actions que le joueur peut effectuer lors d'un tour,\r\n     * et qui permet au joueur d'en effectuer une\r\n     * @param ticketsHandler\r\n     * @param cardHandler\r\n     * @param routeHandler\r\n     */\r\n    public void startTurn(DrawTicketsHandler ticketsHandler, DrawCardHandler cardHandler, ClaimRouteHandler routeHandler){\r\n        assert isFxApplicationThread();\r\n        if(observableGameState.canDrawTickets())\r\n            drawTicketsHandlerProperty.set(() -> {\r\n                ticketsHandler.onDrawTickets();\r\n                viderHandlers();\r\n            });\r\n        if(observableGameState.canDrawCards())\r\n            drawCardHandlerProperty.set(slot -> {\r\n                cardHandler.onDrawCard(slot);\r\n                viderHandlers();\r\n            });\r\n        drawClaimRouteHandlerProperty.set((route, cards) -> {\r\n            routeHandler.onClaimRoute(route, cards);\r\n            viderHandlers();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Ouvre une fenêtre permettant au joueur de faire son choix.\r\n     * Une fois celui-ci confirmé, le gestionnaire de choix est appelé avec ce choix en argument\r\n     * @param bag multiensemble de 5 ou 3 billets\r\n     * @param handler gestionnaire de tickets\r\n     * @throws IllegalArgumentException si le multiensemble n'est pas de taille 5 ou 3\r\n     * @throws AssertionError si le fil d'éxecution s'arrête\r\n     */\r\n    public void chooseTickets(SortedBag<Ticket> bag, ChooseTicketsHandler handler){\r\n        assert isFxApplicationThread();\r\n        Preconditions.checkArgument(bag.size() == Constants.INITIAL_TICKETS_COUNT || bag.size() == Constants.IN_GAME_TICKETS_COUNT);\r\n\r\n        Text text = new Text(String.format(StringsFr.CHOOSE_TICKETS, bag.size() - 2, plural(bag.size()-2)));\r\n        TextFlow textFlow = new TextFlow(text);\r\n\r\n        ListView<Ticket> listView = new ListView<>(FXCollections.observableList(bag.toList()));\r\n        listView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);\r\n\r\n        Button button = new Button(CHOOSE);\r\n        button.disableProperty().bind(Bindings.size(listView.getSelectionModel().getSelectedItems()).lessThan((bag.size()-2)));\r\n\r\n        Stage stage = createStage(StringsFr.TICKETS_CHOICE,\r\n                new VBox(textFlow, listView, button));\r\n\r\n        button.setOnAction( c -> {\r\n            stage.hide();\r\n            handler.onChooseTickets(SortedBag.of(listView.getSelectionModel().getSelectedItems()));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Méthode qui autorise le joueur a choisir une carte wagon/locomotive,\r\n     * soit l'une des cinq dont la face est visible,\r\n     * soit celle du sommet de la pioche; une fois que le joueur a cliqué sur l'une de ces cartes,\r\n     * le gestionnaire est appelé avec le choix du joueur;\r\n     * cette méthode est destinée à être appelée lorsque le joueur a déjà tiré une première carte et doit maintenant tirer la seconde\r\n     * @param handler un gestionnaire de tirage\r\n     * @throws AssertionError si le fil d'execution est arrêtée\r\n     */\r\n    public void drawCard(DrawCardHandler handler){\r\n        assert isFxApplicationThread();\r\n        drawCardHandlerProperty.set(slot -> {\r\n            handler.onDrawCard(slot);\r\n            viderHandlers();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Ouvre une fenêtre permettant au joueur de faire son choix.\r\n     * Une fois celui-ci confirmé, le gestionnaire de choix est appelé avec ce choix en argument\r\n     * @param list list de multiensemble de cartes initiales pour s'emparer d'une route\r\n     * @param handler gestionnaire de cartes\r\n     * @throws AssertionError si le fil d'éxecution s'arrête\r\n     */\r\n    public void chooseClaimCards(List<SortedBag<Card>> list, ChooseCardsHandler handler){\r\n        createCardWindow(CHOOSE_CARDS, list, handler);\r\n    }\r\n\r\n\r\n    /**\r\n     * Ouvre une fenêtre permettant au joueur de faire son choix.\r\n     * Une fois celui-ci confirmé, le gestionnaire de choix est appelé avec ce choix en argument\r\n     * @param list list de multiensemble de cartes\r\n     * @param handler gestionnaire de cartes\r\n     * @throws AssertionError si le fil d'éxecution s'arrête\r\n     */\r\n    public void chooseAdditionalCards(List<SortedBag<Card>> list, ChooseCardsHandler handler){\r\n        createCardWindow(CHOOSE_ADDITIONAL_CARDS, list, handler);\r\n    }\r\n\r\n    public void showWinner(String winner, int points, RestartHandler handler){\r\n        assert isFxApplicationThread();\r\n        Pane pane = new VBox();\r\n        Stage stage = createStage(\"Fin de la Partie\", pane);\r\n        stage.setHeight(300);\r\n        stage.setWidth(500);\r\n        stage.setOnCloseRequest(v -> stage.close());\r\n        String winnerString = winner == null\r\n                ? String.format(\"Vous êtes à égalité avec %s points\", points)\r\n                : String.format(\"Bravo à %s qui a gagné la partie avec %s points!\", winner, points);\r\n\r\n        Text winnerText = new Text(10,20, winnerString);\r\n        winnerText.setFont(Font.font(\"Calibri\", 20));\r\n\r\n\r\n        Text rejouer = new Text(\"Voulez vous rejouer?\");\r\n        rejouer.setFont(Font.font(\"Calibri\", 15));\r\n        Button ouiButton = new Button(\"Oui\");\r\n        Button nonButton = new Button(\"Non\");\r\n\r\n        pane.getChildren().addAll(winnerText, rejouer, ouiButton,nonButton);\r\n        ouiButton.setOnAction(e ->{\r\n                    ouiButton.disableProperty().set(true);\r\n                    mainStage.close();\r\n                    handler.onClick(1);\r\n                });\r\n        nonButton.setOnAction(e -> {\r\n            nonButton.disableProperty().set(true);\r\n            mainStage.close();\r\n            handler.onClick(0);\r\n        });\r\n\r\n        //nonButton.setOnAction(e ->\r\n                //handler.onClick(0));\r\n\r\n    }\r\n\r\n    /**\r\n     * Crée le Stage\r\n     * @param title\r\n     * @param pane\r\n     * @return Stage\r\n     */\r\n    private Stage createStage(String title, Pane pane){\r\n        Scene scene = new Scene(pane);\r\n        scene.getStylesheets().add(\"chooser.css\");\r\n        Stage stage = new Stage(StageStyle.UTILITY);\r\n        stage.setTitle(title);\r\n        stage.initOwner(mainStage);\r\n        stage.initModality(Modality.WINDOW_MODAL);\r\n        stage.setOnCloseRequest(Event::consume);\r\n        stage.setScene(scene);\r\n        stage.show();\r\n        return stage;\r\n    }\r\n\r\n    /**\r\n     * Crée la fenêtre pour choisir des cartes\r\n     * @param string\r\n     * @param list\r\n     * @param handler\r\n     */\r\n    private void createCardWindow(String string, List<SortedBag<Card>> list, ChooseCardsHandler handler){\r\n        assert isFxApplicationThread();\r\n        Text text = new Text(string);\r\n        TextFlow textFlow = new TextFlow(text);\r\n\r\n        ListView<SortedBag<Card>> listView = new ListView<>(FXCollections.observableList(list));\r\n        listView.setCellFactory(v -> new TextFieldListCell<>(new CardBagStringConverter()));\r\n\r\n        Button button = new Button(CHOOSE);\r\n        Stage stage = createStage(CARDS_CHOICE,\r\n                new VBox(textFlow, listView, button));\r\n\r\n        boolean stringContent = string.equals(CHOOSE_CARDS);\r\n        ObservableList<SortedBag<Card>> selectedItems = listView.getSelectionModel().getSelectedItems();\r\n\r\n        if (stringContent)\r\n            button.disableProperty().bind(Bindings.size(selectedItems).isEqualTo(0));\r\n\r\n        button.setOnAction( c -> {\r\n            stage.hide();\r\n            SortedBag<Card> cards = (!selectedItems.isEmpty()) || stringContent\r\n                    ? listView.getSelectionModel().getSelectedItem()\r\n                    : SortedBag.of();\r\n            handler.onChooseCards(cards);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Vide les ObjectProperties contenant les handlers\r\n     */\r\n    private void viderHandlers(){\r\n        drawTicketsHandlerProperty.set(null);\r\n        drawCardHandlerProperty.set(null);\r\n        drawClaimRouteHandlerProperty.set(null);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n     * Class privée CardBagStringConverter\r\n     */\r\n    private static class CardBagStringConverter extends StringConverter<SortedBag<Card>> {\r\n\r\n        /**\r\n         * Converts the object provided into its string form.\r\n         * Format of the returned string is defined by the specific converter.\r\n         *\r\n         * @param object the object of type {@code T} to convert\r\n         * @return a string representation of the object passed in.\r\n         */\r\n        @Override\r\n        public String toString(SortedBag<Card> object) {\r\n            List<String> strings = object.toSet().stream()\r\n                    .map(card -> String.format(\"%s %s\", object.countOf(card), Info.cardName(card, object.countOf(card))))\r\n                    .collect(Collectors.toList());\r\n            switch(strings.size()){\r\n                case(1):\r\n                    return strings.get(0);\r\n                case(2):\r\n                    return String.join(AND_SEPARATOR, strings);\r\n                default:\r\n                    return String.join(\", \", strings.subList(0, strings.size() - 1)) + AND_SEPARATOR\r\n                            + strings.get(strings.size() - 1);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Converts the string provided into an object defined by the specific converter.\r\n         * Format of the string and type of the resulting object is defined by the specific converter.\r\n         *\r\n         * @param string the {@code String} to convert\r\n         * @return an object representation of the string passed in.\r\n         */\r\n        @Override\r\n        public SortedBag<Card> fromString(String string) {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ch/epfl/tchu/gui/GraphicalPlayer.java b/src/ch/epfl/tchu/gui/GraphicalPlayer.java
--- a/src/ch/epfl/tchu/gui/GraphicalPlayer.java	(revision 39692f47bf3d5f4bad8b0c09ed47c6feaa8b3b7d)
+++ b/src/ch/epfl/tchu/gui/GraphicalPlayer.java	(date 1621602047234)
@@ -296,9 +296,6 @@
     }
 
 
-
-
-
     /**
      * Class privée CardBagStringConverter
      */
Index: src/ch/epfl/tchu/net/Serdes.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ch.epfl.tchu.net;\r\n\r\nimport ch.epfl.tchu.Preconditions;\r\nimport ch.epfl.tchu.SortedBag;\r\nimport ch.epfl.tchu.game.*;\r\nimport ch.epfl.tchu.gui.ServerMain;\r\n\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.util.*;\r\nimport java.util.regex.Pattern;\r\n\r\n/**\r\n * La classe Serdes non instanciable, contient la totalité des serdes utiles au projet.\r\n * @author Shangeeth Poobalasingam (329307)\r\n * @author Marvin Koch (324448)\r\n */\r\npublic final class Serdes {\r\n    private Serdes(){}\r\n\r\n    /**\r\n     * Serde des Entiers\r\n     */\r\n    public static final Serde<Integer> INTEGER_SERDE = Serde.of(i -> Integer.toString(i), Integer::parseInt);\r\n\r\n    /**\r\n     * Serde des Chaînes\r\n     */\r\n    public static final Serde<String> STRING_SERDE = Serde.of(\r\n            s -> Base64.getEncoder().encodeToString(s.getBytes(StandardCharsets.UTF_8)),\r\n            b -> new String((Base64.getDecoder().decode(b)), StandardCharsets.UTF_8));\r\n\r\n    /**\r\n     * Serde de PlayerID\r\n     */\r\n    public static final Serde<PlayerId> PLAYER_ID_SERDE= Serde.oneOf(PlayerId.ALL);\r\n\r\n    /**\r\n     * Serde de TurnKind\r\n     */\r\n    public static final Serde<Player.TurnKind> TURN_KIND_SERDE= Serde.oneOf(Player.TurnKind.ALL);\r\n\r\n    /**\r\n     * Serde de Card\r\n     */\r\n    public static final Serde<Card> CARD_SERDE= Serde.oneOf(Card.ALL);\r\n\r\n    /**\r\n     * Serde de Route\r\n     */\r\n    public static final Serde<Route> ROUTE_SERDE= Serde.oneOf(ChMap.routes());\r\n\r\n    /**\r\n     * Serde de Ticket\r\n     */\r\n    public static final Serde<Ticket> TICKET_SERDE = Serde.oneOf(ChMap.tickets());\r\n\r\n    /**\r\n     * Serde d'une liste de String\r\n     */\r\n    public static final Serde<List<String>> LIST_STRING_SERDE = Serde.listOf(STRING_SERDE,\",\");\r\n\r\n    /**\r\n     * Serde d'une liste de Card\r\n     */\r\n    public static final Serde<List<Card>> LIST_CARD_SERDE = Serde.listOf(CARD_SERDE,\",\");\r\n\r\n    /**\r\n     * Serde d'une liste de Route\r\n     */\r\n    public static final Serde<List<Route>> LIST_ROUTE_SERDE = Serde.listOf(ROUTE_SERDE, \",\");\r\n\r\n    /**\r\n     * Serde d'un multiensemble de Card\r\n     */\r\n    public static final Serde<SortedBag<Card>> SORTEDBAG_CARD_SERDE = Serde.bagOf(CARD_SERDE, \",\");\r\n    /**\r\n     * Serde d'un SortedBag de Ticket\r\n     */\r\n    public static final Serde<SortedBag<Ticket>> SORTEDBAG_TICKET_SERDE = Serde.bagOf(TICKET_SERDE, \",\");\r\n\r\n    /**\r\n     * Serde d'une liste de SortedBag de Card\r\n     */\r\n    public static final Serde<List<SortedBag<Card>>> LIST_SORTEDBAG_CARD_SERDE = Serde.listOf(SORTEDBAG_CARD_SERDE,\";\");\r\n\r\n    /**\r\n     *  Serde d'un PublicCardState\r\n     */\r\n    public static final Serde<PublicCardState> PUBLIC_CARD_STATE_SERDE = new Serde<PublicCardState>() {\r\n        @Override\r\n        public String serialize(PublicCardState publicCardState) {\r\n\r\n            return String.join(\";\",\r\n                    LIST_CARD_SERDE.serialize(publicCardState.faceUpCards()),\r\n                    INTEGER_SERDE.serialize(publicCardState.deckSize()),\r\n                    INTEGER_SERDE.serialize(publicCardState.discardsSize()));\r\n        }\r\n\r\n        @Override\r\n        public PublicCardState deserialize(String s) {\r\n            String[] splitString = s.split(Pattern.quote(\";\"), -1);\r\n            Preconditions.checkArgument(splitString.length == 3);\r\n            return new PublicCardState(LIST_CARD_SERDE.deserialize(splitString[0]),\r\n                    INTEGER_SERDE.deserialize(splitString[1]),\r\n                    INTEGER_SERDE.deserialize(splitString[2]));\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Serde d'un PublicPlayerState\r\n     */\r\n    public static final Serde<PublicPlayerState> PUBLIC_PLAYER_STATE_SERDE = new Serde<PublicPlayerState>() {\r\n        @Override\r\n        public String serialize(PublicPlayerState publicPlayerState) {\r\n            return String.join(\";\", INTEGER_SERDE.serialize(publicPlayerState.ticketCount()),\r\n                    INTEGER_SERDE.serialize(publicPlayerState.cardCount()),\r\n                    LIST_ROUTE_SERDE.serialize(publicPlayerState.routes()));\r\n\r\n        }\r\n\r\n        @Override\r\n        public PublicPlayerState deserialize(String s) {\r\n            String[] splitString = s.split(Pattern.quote(\";\"), -1);\r\n            Preconditions.checkArgument(splitString.length == 3);\r\n            return new PublicPlayerState(INTEGER_SERDE.deserialize(splitString[0]),\r\n                    INTEGER_SERDE.deserialize(splitString[1]),\r\n                    LIST_ROUTE_SERDE.deserialize(splitString[2]));\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Serde d'un PlayerState\r\n     */\r\n    public static final Serde<PlayerState> PLAYER_STATE_SERDE = new Serde<PlayerState>() {\r\n        @Override\r\n        public String serialize(PlayerState playerState) {\r\n            return String.join(\";\",SORTEDBAG_TICKET_SERDE.serialize(playerState.tickets()),\r\n                    SORTEDBAG_CARD_SERDE.serialize(playerState.cards()),\r\n                    LIST_ROUTE_SERDE.serialize(playerState.routes()));\r\n        }\r\n\r\n        @Override\r\n        public PlayerState deserialize(String s) {\r\n            String[] splitString = s.split(Pattern.quote(\";\"), -1);\r\n            Preconditions.checkArgument(splitString.length == 3);\r\n            return new PlayerState(SORTEDBAG_TICKET_SERDE.deserialize(splitString[0]),\r\n                    SORTEDBAG_CARD_SERDE.deserialize(splitString[1]),\r\n                    LIST_ROUTE_SERDE.deserialize(splitString[2]));\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Serde d'un publicGameState\r\n     */\r\n    public static final Serde<PublicGameState> PUBLIC_GAME_STATE_SERDE = new Serde<PublicGameState>() {\r\n        @Override\r\n        public String serialize(PublicGameState publicGameState) {\r\n            if(ServerMain.is3Player){\r\n                return String.join(\":\", INTEGER_SERDE.serialize(publicGameState.ticketsCount()),\r\n                        PUBLIC_CARD_STATE_SERDE.serialize(publicGameState.cardState()),\r\n                        PLAYER_ID_SERDE.serialize(publicGameState.currentPlayerId()),\r\n                        PUBLIC_PLAYER_STATE_SERDE.serialize(publicGameState.playerState(PlayerId.PLAYER_1)),\r\n                        PUBLIC_PLAYER_STATE_SERDE.serialize(publicGameState.playerState(PlayerId.PLAYER_2)),\r\n                        PUBLIC_PLAYER_STATE_SERDE.serialize(publicGameState.playerState(PlayerId.PLAYER_3)),\r\n                        PLAYER_ID_SERDE.serialize(publicGameState.lastPlayer()));\r\n            }else{\r\n                return String.join(\":\", INTEGER_SERDE.serialize(publicGameState.ticketsCount()),\r\n                        PUBLIC_CARD_STATE_SERDE.serialize(publicGameState.cardState()),\r\n                        PLAYER_ID_SERDE.serialize(publicGameState.currentPlayerId()),\r\n                        PUBLIC_PLAYER_STATE_SERDE.serialize(publicGameState.playerState(PlayerId.PLAYER_1)),\r\n                        PUBLIC_PLAYER_STATE_SERDE.serialize(publicGameState.playerState(PlayerId.PLAYER_2)),\r\n                        PLAYER_ID_SERDE.serialize(publicGameState.lastPlayer()));\r\n            }\r\n\r\n        }\r\n\r\n        @Override\r\n        public PublicGameState deserialize(String s) {\r\n            String[] splitString = s.split(Pattern.quote(\":\"), -1);\r\n            //Preconditions.checkArgument(splitString.length == 6);\r\n            Map<PlayerId, PublicPlayerState> map = new HashMap<>();\r\n            map.put(PlayerId.PLAYER_1, PUBLIC_PLAYER_STATE_SERDE.deserialize(splitString[3]));\r\n            map.put(PlayerId.PLAYER_2, PUBLIC_PLAYER_STATE_SERDE.deserialize(splitString[4]));\r\n            int index;\r\n            if(ServerMain.is3Player) {\r\n                map.put(PlayerId.PLAYER_3, PUBLIC_PLAYER_STATE_SERDE.deserialize(splitString[5]));\r\n                index = 6;\r\n            }else {\r\n                index = 5;\r\n            }\r\n            return new PublicGameState(INTEGER_SERDE.deserialize(splitString[0]),\r\n                    PUBLIC_CARD_STATE_SERDE.deserialize(splitString[1]),\r\n                    PLAYER_ID_SERDE.deserialize(splitString[2]),\r\n                    map,\r\n                    PLAYER_ID_SERDE.deserialize(splitString[index]));\r\n        }\r\n    };\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ch/epfl/tchu/net/Serdes.java b/src/ch/epfl/tchu/net/Serdes.java
--- a/src/ch/epfl/tchu/net/Serdes.java	(revision 39692f47bf3d5f4bad8b0c09ed47c6feaa8b3b7d)
+++ b/src/ch/epfl/tchu/net/Serdes.java	(date 1621608423793)
@@ -174,6 +174,7 @@
 
         }
 
+        //TODO ajouter player
         @Override
         public PublicGameState deserialize(String s) {
             String[] splitString = s.split(Pattern.quote(":"), -1);
Index: src/ch/epfl/tchu/net/RemotePlayerClient.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ch.epfl.tchu.net;\r\n\r\nimport ch.epfl.tchu.SortedBag;\r\nimport ch.epfl.tchu.game.*;\r\n\r\nimport java.io.*;\r\nimport java.net.Socket;\r\nimport java.util.EnumMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Objects;\r\nimport java.util.regex.Pattern;\r\nimport static ch.epfl.tchu.net.Serdes.*;\r\n\r\nimport static java.nio.charset.StandardCharsets.US_ASCII;\r\n\r\n/**\r\n * La classe instanciable RemotePlayerClient représente un client de joueur distant.\r\n *\r\n * @author Shangeeth Poobalasingam (329307)\r\n * @author Marvin Koch (324448)\r\n */\r\n\r\npublic final class RemotePlayerClient{\r\n    private final Player player;\r\n    private final String name;\r\n    private final int port;\r\n\r\n    /**\r\n     * Constructeur de RemotePlayerClient\r\n     * @param player Player\r\n     * @param name le nom\r\n     * @param port nombre du port\r\n     */\r\n    public RemotePlayerClient(Player player, String name, int port){\r\n        this.player = player;\r\n        this.name = Objects.requireNonNull(name);\r\n        this.port = port;\r\n    }\r\n\r\n    /**\r\n     * Cette méthode effectue une boucle durant laquelle elle:\r\n     *    - attend un message en provenance du mandataire,\r\n     *    - le découpe en utilisant le caractère d'espacement comme séparateur,\r\n     *    - détermine le type du message en fonction de la première chaîne résultant du découpage,\r\n     *      en fonction de ce type de message, désérialise les arguments, appelle la méthode correspondante du joueur;\r\n     *      si cette méthode retourne un résultat, le sérialise pour le renvoyer au mandataire en réponse.\r\n     */\r\n    public void run(){\r\n        try(Socket s = new Socket(name, port);\r\n             BufferedReader r =\r\n                     new BufferedReader(\r\n                             new InputStreamReader(s.getInputStream(),\r\n                                     US_ASCII));\r\n             BufferedWriter w =\r\n                     new BufferedWriter(\r\n                             new OutputStreamWriter(s.getOutputStream(),\r\n                                     US_ASCII))) {\r\n\r\n            String line;\r\n            while((line = r.readLine())!= null){\r\n                String[] strings = line.split(Pattern.quote(\" \"));\r\n                switch (MessageId.valueOf(strings[0])){\r\n                    case INIT_PLAYERS:\r\n                        List<String> playerNames = LIST_STRING_SERDE.deserialize(strings[2]);\r\n                        Map<PlayerId, String> mapNames = new EnumMap<>(PlayerId.class);\r\n                        mapNames.put(PlayerId.PLAYER_1, playerNames.get(0));\r\n                        mapNames.put(PlayerId.PLAYER_2, playerNames.get(1));\r\n                        player.initPlayers(PLAYER_ID_SERDE.deserialize(strings[1]), mapNames);\r\n                        break;\r\n                    case RECEIVE_INFO:\r\n                        player.receiveInfo(STRING_SERDE.deserialize(strings[1]));\r\n                        break;\r\n                    case UPDATE_STATE:\r\n                        player.updateState(PUBLIC_GAME_STATE_SERDE.deserialize(strings[1]),PLAYER_STATE_SERDE.deserialize(strings[2]));\r\n                        break;\r\n                    case CHOOSE_INITIAL_TICKETS:\r\n                        writeMessage(SORTEDBAG_TICKET_SERDE.serialize(player.chooseInitialTickets()), w);\r\n                        break;\r\n                    case NEXT_TURN:\r\n                        writeMessage(TURN_KIND_SERDE.serialize(player.nextTurn()), w);\r\n                        break;\r\n                    case CHOOSE_TICKETS:\r\n                        SortedBag<Ticket> options = SORTEDBAG_TICKET_SERDE.deserialize(strings[1]);\r\n                        writeMessage(SORTEDBAG_TICKET_SERDE.serialize(player.chooseTickets(options)), w);\r\n                        break;\r\n                    case DRAW_SLOT:\r\n                        writeMessage(INTEGER_SERDE.serialize(player.drawSlot()), w);\r\n                        break;\r\n                    case ROUTE:\r\n                        writeMessage(ROUTE_SERDE.serialize(player.claimedRoute()), w);\r\n                        break;\r\n                    case CARDS:\r\n                        writeMessage(SORTEDBAG_CARD_SERDE.serialize(player.initialClaimCards()), w);\r\n                        break;\r\n                    case CHOOSE_ADDITIONAL_CARDS:\r\n                        List<SortedBag<Card>> listSortedBagCards = LIST_SORTEDBAG_CARD_SERDE.deserialize(strings[1]);\r\n                        writeMessage(SORTEDBAG_CARD_SERDE.serialize(player.chooseAdditionalCards(listSortedBagCards)), w);\r\n                        break;\r\n                    case SET_INITIAL_TICKETS:\r\n                        player.setInitialTicketChoice(SORTEDBAG_TICKET_SERDE.deserialize(strings[1]));\r\n                        break;\r\n                    case END:\r\n                        writeMessage(INTEGER_SERDE.serialize(player.endMenu(STRING_SERDE.deserialize(strings[1]), INTEGER_SERDE.deserialize(strings[2]))), w);\r\n                        break;\r\n                }\r\n            }\r\n\r\n        } catch (IOException e) {\r\n            throw new UncheckedIOException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Ecrit un message\r\n     * @param s String\r\n     * @param w BufferedWriter\r\n     */\r\n    private void writeMessage(String s, BufferedWriter w){\r\n        try{\r\n            w.write(s);\r\n            w.write('\\n');\r\n            w.flush();\r\n        }catch (IOException e){\r\n            throw new UncheckedIOException(e);\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ch/epfl/tchu/net/RemotePlayerClient.java b/src/ch/epfl/tchu/net/RemotePlayerClient.java
--- a/src/ch/epfl/tchu/net/RemotePlayerClient.java	(revision 39692f47bf3d5f4bad8b0c09ed47c6feaa8b3b7d)
+++ b/src/ch/epfl/tchu/net/RemotePlayerClient.java	(date 1621608927488)
@@ -5,10 +5,7 @@
 
 import java.io.*;
 import java.net.Socket;
-import java.util.EnumMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
+import java.util.*;
 import java.util.regex.Pattern;
 import static ch.epfl.tchu.net.Serdes.*;
 
@@ -63,9 +60,10 @@
                 switch (MessageId.valueOf(strings[0])){
                     case INIT_PLAYERS:
                         List<String> playerNames = LIST_STRING_SERDE.deserialize(strings[2]);
-                        Map<PlayerId, String> mapNames = new EnumMap<>(PlayerId.class);
-                        mapNames.put(PlayerId.PLAYER_1, playerNames.get(0));
-                        mapNames.put(PlayerId.PLAYER_2, playerNames.get(1));
+                        Map<PlayerId, String> mapNames = new HashMap<>();
+                        for(int i = 0; i < PlayerId.ALL.size(); ++i){
+                            mapNames.put(PlayerId.ALL.get(i), playerNames.get(i));
+                        }
                         player.initPlayers(PLAYER_ID_SERDE.deserialize(strings[1]), mapNames);
                         break;
                     case RECEIVE_INFO:
Index: src/ch/epfl/tchu/game/Game.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ch.epfl.tchu.game;\r\n\r\nimport ch.epfl.tchu.Preconditions;\r\nimport ch.epfl.tchu.SortedBag;\r\nimport ch.epfl.tchu.gui.Info;\r\nimport ch.epfl.tchu.game.Constants;\r\n\r\nimport java.util.*;\r\nimport java.util.concurrent.ArrayBlockingQueue;\r\nimport java.util.concurrent.BlockingDeque;\r\nimport java.util.concurrent.BlockingQueue;\r\n\r\nimport static ch.epfl.tchu.game.Constants.*;\r\n\r\n/**\r\n * La classe Game publique, finale et non instanciable, représente une partie de tCHu.\r\n * @author Shangeeth Poobalasingam (329307)\r\n * @author Marvin Koch (324448)\r\n */\r\npublic final class Game {\r\n    /**\r\n     * Fait jouer une partie de tCHu aux joueurs donnés, dont les noms figurent dans la table playerNames,\r\n     * les billets disponibles pour cette partie sont ceux de tickets,\r\n     * et le générateur aléatoire rng est utilisé pour créer l'état initial du jeu\r\n     * et pour mélanger les cartes de la défausse pour en faire une nouvelle pioche quand cela est nécessaire\r\n     * @param players map des 2 players\r\n     * @param playerNames map des 2 noms des joueurs\r\n     * @param tickets tas de billets\r\n     * @param rng une instance de Random\r\n     * @throws IllegalArgumentException si l'une des deux tables associatives a une taille différente de 2\r\n     */\r\n    public static void play(Map<PlayerId, Player> players, Map<PlayerId, String> playerNames, SortedBag<Ticket> tickets, Random rng) {\r\n        boolean play = false;\r\n        do {\r\n            Preconditions.checkArgument(playerNames.size() == PlayerId.COUNT && players.size() == PlayerId.COUNT);\r\n            GameState gameState = GameState.initial(tickets, rng);\r\n            Map<PlayerId, Info> infos = new HashMap<>();\r\n            PlayerId.ALL.forEach(id -> infos.put(id, new Info(playerNames.get(id))));\r\n\r\n            players.forEach((id, player) -> player.initPlayers(id, playerNames));\r\n            receiveInfoAll(players, infos.get(gameState.currentPlayerId()).willPlayFirst());\r\n\r\n            for (PlayerId id : PlayerId.values()) {\r\n                SortedBag<Ticket> ticketSortedBag = gameState.topTickets(INITIAL_TICKETS_COUNT);\r\n                gameState = gameState.withoutTopTickets(INITIAL_TICKETS_COUNT);\r\n                players.get(id).setInitialTicketChoice(ticketSortedBag);\r\n            }\r\n\r\n            updateStateForPlayers(players, gameState);\r\n            for (PlayerId id : PlayerId.values()) {\r\n                gameState = gameState.withInitiallyChosenTickets(id, players.get(id).chooseInitialTickets());\r\n            }\r\n\r\n            GameState finalGameState = gameState;\r\n            players.forEach((id, player) -> receiveInfoAll(players, infos.get(id).keptTickets(finalGameState.playerState(id).ticketCount())));\r\n            int count = 0; //todo\r\n            boolean gameHasEnded = false;\r\n            while (!gameHasEnded) {\r\n                Player currentPlayer = players.get(gameState.currentPlayerId());\r\n                Info currentInfo = infos.get(gameState.currentPlayerId());\r\n                Info nextInfo = infos.get(gameState.currentPlayerId().next());\r\n                PlayerState currentPlayerState = gameState.currentPlayerState();\r\n                PlayerState nextPlayerState = gameState.playerState(gameState.currentPlayerId().next());\r\n\r\n                updateStateForPlayers(players, gameState);\r\n                receiveInfoAll(players, currentInfo.canPlay());\r\n                Player.TurnKind turn = currentPlayer.nextTurn();\r\n                switch (turn) {\r\n                    case DRAW_TICKETS:\r\n                        SortedBag<Ticket> topTickets = gameState.topTickets(IN_GAME_TICKETS_COUNT);\r\n                        receiveInfoAll(players, currentInfo.drewTickets(IN_GAME_TICKETS_COUNT));\r\n                        SortedBag<Ticket> chosen = currentPlayer.chooseTickets(topTickets);\r\n                        receiveInfoAll(players, currentInfo.keptTickets(chosen.size()));\r\n                        gameState = gameState.withChosenAdditionalTickets(topTickets, chosen);\r\n                        break;\r\n\r\n                    case DRAW_CARDS:\r\n                        for (int i = 0; i < 2; ++i) {\r\n                            if (i == 1) {\r\n                                updateStateForPlayers(players, gameState);\r\n                            }\r\n                            gameState = gameState.withCardsDeckRecreatedIfNeeded(rng);\r\n                            int slot = currentPlayer.drawSlot();\r\n                            if (slot == Constants.DECK_SLOT) {\r\n                                receiveInfoAll(players, currentInfo.drewBlindCard());\r\n                                gameState = gameState.withBlindlyDrawnCard();\r\n\r\n                            } else {\r\n                                receiveInfoAll(players, currentInfo.drewVisibleCard(gameState.cardState().faceUpCard(slot)));\r\n                                gameState = gameState.withDrawnFaceUpCard(slot);\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    case CLAIM_ROUTE:\r\n                        Route claimedRoute = currentPlayer.claimedRoute();\r\n                        SortedBag<Card> initialCards = currentPlayer.initialClaimCards();\r\n\r\n                        if (!currentPlayerState.canClaimRoute(claimedRoute)) {\r\n                            //cas si le joueur ne peut pas claim la route\r\n                            receiveInfoAll(players, currentInfo.didNotClaimRoute(claimedRoute));\r\n                        } else {\r\n                            if (claimedRoute.level().equals(Route.Level.OVERGROUND)) {\r\n                                // cas si la route est une route normal\r\n                                gameState = gameState.withClaimedRoute(claimedRoute, initialCards);\r\n                                receiveInfoAll(players, currentInfo.claimedRoute(claimedRoute, initialCards));\r\n\r\n                            } else {\r\n                                // cas si la route est un tunnel\r\n                                receiveInfoAll(players, currentInfo.attemptsTunnelClaim(claimedRoute, initialCards));\r\n                                SortedBag.Builder<Card> cardsBuilder = new SortedBag.Builder<>();\r\n                                for (int i = 0; i < Constants.ADDITIONAL_TUNNEL_CARDS; i++) {\r\n                                    gameState = gameState.withCardsDeckRecreatedIfNeeded(rng);\r\n                                    cardsBuilder.add(gameState.topCard());\r\n                                    gameState = gameState.withoutTopCard();\r\n                                }\r\n\r\n                                SortedBag<Card> cards = cardsBuilder.build();\r\n                                int additionalCardsCount = claimedRoute.additionalClaimCardsCount(initialCards, cards);\r\n                                receiveInfoAll(players, currentInfo.drewAdditionalCards(cards, additionalCardsCount));\r\n\r\n                                if (additionalCardsCount == 0) {\r\n                                    // cas ou il y a aucune cartes additionnels\r\n                                    gameState = gameState.withClaimedRoute(claimedRoute, initialCards);\r\n                                    receiveInfoAll(players, currentInfo.claimedRoute(claimedRoute, initialCards));\r\n                                } else {\r\n                                    // cas ou il y a des cartes additionnels\r\n                                    List<SortedBag<Card>> list = currentPlayerState.possibleAdditionalCards(additionalCardsCount, initialCards);\r\n                                    if (!list.isEmpty()) {\r\n                                        // cas ou il possede les cartes additionnels necessaires\r\n                                        SortedBag<Card> suite = currentPlayer.chooseAdditionalCards(list);\r\n                                        if (!suite.isEmpty()) {\r\n                                            // cas ou il decide de jouer ses cartes additionnels\r\n                                            SortedBag<Card> union = suite.union(initialCards);\r\n                                            gameState = gameState.withClaimedRoute(claimedRoute, union);\r\n                                            receiveInfoAll(players, currentInfo.claimedRoute(claimedRoute, union));\r\n                                        } else {\r\n                                            // cas ou il decide de ne pas jouer ses cartes additionnels\r\n                                            receiveInfoAll(players, currentInfo.didNotClaimRoute(claimedRoute));\r\n                                        }\r\n                                    } else {\r\n                                        // cas ou il ne possede pas les cartes additionnels necessaires\r\n                                        receiveInfoAll(players, currentInfo.didNotClaimRoute(claimedRoute));\r\n                                    }\r\n                                }\r\n                                gameState = gameState.withMoreDiscardedCards(cards);\r\n                            }\r\n                        }\r\n                        break;\r\n                }\r\n\r\n                if (gameState.lastTurnBegins()) {\r\n                    receiveInfoAll(players, currentInfo.lastTurnBegins(currentPlayerState.carCount()));\r\n                }\r\n                // todo  changer ça\r\n                if (count == 3) {\r\n                    //if(!(gameState.lastPlayer() == null) && (gameState.lastPlayer().equals(gameState.currentPlayerId()))){\r\n                    updateStateForPlayers(players, gameState);\r\n                    int currentPlayerPoints = currentPlayerState.finalPoints();\r\n                    int nextPlayerPoints = nextPlayerState.finalPoints();\r\n                    Trail currentPlayerTrail = Trail.longest(currentPlayerState.routes());\r\n                    Trail nextPlayerTrail = Trail.longest(nextPlayerState.routes());\r\n                    String currentPlayerBonus = currentInfo.getsLongestTrailBonus(currentPlayerTrail);\r\n                    String nextPlayerBonus = nextInfo.getsLongestTrailBonus(nextPlayerTrail);\r\n\r\n                    //Calcul du trail le plus long\r\n                    if (currentPlayerTrail.length() > nextPlayerTrail.length()) {\r\n                        currentPlayerPoints += LONGEST_TRAIL_BONUS_POINTS;\r\n                        receiveInfoAll(players, currentPlayerBonus);\r\n                    } else if (currentPlayerTrail.length() < nextPlayerTrail.length()) {\r\n                        nextPlayerPoints += LONGEST_TRAIL_BONUS_POINTS;\r\n                        receiveInfoAll(players, nextPlayerBonus);\r\n                    } else {\r\n                        currentPlayerPoints += LONGEST_TRAIL_BONUS_POINTS;\r\n                        nextPlayerPoints += LONGEST_TRAIL_BONUS_POINTS;\r\n                        receiveInfoAll(players, currentPlayerBonus);\r\n                        receiveInfoAll(players, nextPlayerBonus);\r\n                    }\r\n\r\n                    //Calcul du gagnant\r\n                    String info;\r\n                    String winnerName;\r\n                    int points;\r\n\r\n                    if (currentPlayerPoints > nextPlayerPoints) {\r\n                        info = currentInfo.won(currentPlayerPoints, nextPlayerPoints);\r\n                        winnerName = playerNames.get(gameState.currentPlayerId());\r\n                        points = currentPlayerPoints;\r\n                    } else if (currentPlayerPoints < nextPlayerPoints) {\r\n                        info = nextInfo.won(nextPlayerPoints, currentPlayerPoints);\r\n                        winnerName = playerNames.get(gameState.currentPlayerId().next());\r\n                        points = nextPlayerPoints;\r\n                    } else {\r\n                        info = Info.draw(new ArrayList<>(playerNames.values()), currentPlayerPoints);\r\n                        winnerName = null;\r\n                        points = currentPlayerPoints;\r\n                    }\r\n\r\n                    receiveInfoAll(players, info);\r\n                    //TODO\r\n                    BlockingQueue<Boolean> firstQ = new ArrayBlockingQueue<>(1);\r\n                    BlockingQueue<Boolean> secondQ = new ArrayBlockingQueue<>(1);\r\n                    new Thread(() -> {\r\n                        try {\r\n                            firstQ.put(players.get(PlayerId.PLAYER_1).endMenu(winnerName, points) == 1);\r\n                        } catch (InterruptedException e) {\r\n                            throw new Error();\r\n                        }\r\n                    }).start();\r\n                    new Thread(() -> {\r\n                        try {\r\n                            secondQ.put(players.get(PlayerId.PLAYER_2).endMenu(winnerName, points) == 1);\r\n                        } catch (InterruptedException e) {\r\n                            throw new Error();\r\n                        }\r\n                    }).start();\r\n\r\n                    try {\r\n                        play = firstQ.take() && secondQ.take();\r\n                    } catch (InterruptedException e) {\r\n                        throw new Error();\r\n                    }\r\n\r\n                    gameHasEnded = true;\r\n                }//todo ici aussi\r\n                gameState = gameState.forNextTurn();\r\n                count++;\r\n            }\r\n        }while(play);\r\n    }\r\n\r\n    /**\r\n     * Constructuer privée\r\n     */\r\n    private Game(){}\r\n    /**\r\n     * Communique une information a tout les joueurs\r\n     * @param players map des 2 players\r\n     * @param info String à communiquer\r\n     */\r\n    private static void receiveInfoAll(Map<PlayerId, Player> players, String info){\r\n        PlayerId.ALL.forEach(id -> players.get(id).receiveInfo(info));\r\n    }\r\n\r\n    /**\r\n     * Mets à jour l'état de tout les joueurs\r\n     * @param players map des 2 players\r\n     * @param gameState l'etat du jeu\r\n     */\r\n    private static void updateStateForPlayers(Map<PlayerId, Player> players,GameState gameState){\r\n        PlayerId.ALL.forEach(id -> players.get(id).updateState(gameState, gameState.playerState(id)));\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ch/epfl/tchu/game/Game.java b/src/ch/epfl/tchu/game/Game.java
--- a/src/ch/epfl/tchu/game/Game.java	(revision 39692f47bf3d5f4bad8b0c09ed47c6feaa8b3b7d)
+++ b/src/ch/epfl/tchu/game/Game.java	(date 1621609751468)
@@ -40,14 +40,14 @@
             players.forEach((id, player) -> player.initPlayers(id, playerNames));
             receiveInfoAll(players, infos.get(gameState.currentPlayerId()).willPlayFirst());
 
-            for (PlayerId id : PlayerId.values()) {
+            for (PlayerId id : PlayerId.ALL) {
                 SortedBag<Ticket> ticketSortedBag = gameState.topTickets(INITIAL_TICKETS_COUNT);
                 gameState = gameState.withoutTopTickets(INITIAL_TICKETS_COUNT);
                 players.get(id).setInitialTicketChoice(ticketSortedBag);
             }
 
             updateStateForPlayers(players, gameState);
-            for (PlayerId id : PlayerId.values()) {
+            for (PlayerId id : PlayerId.ALL) {
                 gameState = gameState.withInitiallyChosenTickets(id, players.get(id).chooseInitialTickets());
             }
 
